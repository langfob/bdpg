#===============================================================================

        #  gscp_15z_no_longer_used_but_keep_for_doc_for_the_moment.R

#===============================================================================

document_solutions_df <- function ()
    {
    #  2017 05 13 - BTL
    #  solutions_df is no longer used at all, so commenting all of this part out,
    #  but don't want to get rid of it completely yet because it's useful
    #  information about what these various vectors represent.
    #  Should probably just make a more explicit bit of documentation about that.

    #  2017 05 01 - BTL
    #  Why was I creating the solutions_df?  Is this vestigial?
    #  Right now, it looks like the only column used in it is the optimal solution
    #  column and it's just a copy of cor_solution_vector.

    # {
    #   #browser()
    #   solutions_df = data.frame (puid                 = marxan_best_df_sorted$PUID,
    #                              optimal_solution     = cor_solution_vector,
    #                              marxan_best_solution = marxan_best_df_sorted$SOLUTION, #  assumes already sorted by PU_ID
    #                              marxan_votes         = marxan_ssoln_df$number,
    #                              cor_signed_diff      = cor_signed_difference,
    #                              cor_abs_val_diff     = cor_abs_val_signed_difference,
    #           #  2015 06 19 - BTL
    #           #  Until now (3:04 pm), this said:
    #           #       cor_num_spp_on_patch = final_link_counts_for_each_node$freq
    #           #  That means that it was using the apparent, not the correct,
    #           #  final link counts for each node.
    #           #  I have now changed this to say cor_... instead.
    #           #  Not sure if this was a source of unknown bugs before or will be
    #           #  a source now.  Need to look more closely at this to see the
    #           #  consequences where solutions_df$cor_num_spp_on_patch is used
    #           #  downstream of here.  However, since this is the only place it
    #           #  appears in this file and this file (gscp_15) is at the end of
    #           #  the whole program, maybe it doesn't matter at all except being
    #           #  echoed in some output file.
    #                              cor_num_spp_on_patch = cor_final_link_counts_for_each_node$freq
    #                              )
    #
    # }
    }

#===============================================================================

#  NO LONGER USED - REPLACED BY save_rsrun_results_data_for_one_rsrun - 2017 06 01
# save_rsrun_results_data <- function (rsrun, exp_root_dir, parameters,
#
#                                      marxan_mvbest_df,
#
#                                      app_bpm,
#                                                         app_num_PUs,
#                                                         marxan_best_solution_PU_IDs,
#                                                         marxan_best_num_patches_in_solution,
#                                                         cor_num_patches_in_solution,
#                                                         spp_rep_targets,
#                                                     app_num_spp,
#                                                         DEBUG_LEVEL,
#                                                         FP_const_rate,
#                                                         FN_const_rate
#
#                                      )
#     {
#     results_list = list()
#
#     #---------------------------------------------------------------------------
#
#     results_list$rsr_rsrun_UUID                                                 = rsrun@UUID
#     results_list$rsr_rs_run_checksum                                            = rsrun@checksum
#
#     results_list$rsr_run_on_prob_UUID                                           = rsrun@run_on_prob_UUID
#
#     #---------------------------------------------------------------------------
#
#     results_list$rsr_run_on_prob_UUID                                           = rsrun@run_on_prob_UUID
#
#     results_list$rsr_cor_or_app_str                                             = rsrun@cor_or_app_str
#     results_list$rsr_basic_or_wrapped_or_comb_str                               = rsrun@basic_or_wrapped_or_comb_str
#     results_list$rsr_rs_method_name                                             = rsrun@rs_method_name
#
#     results_list$rsr_input_dir_name                                             = rsrun@input_dir_name
#     results_list$rsr_output_dir_name                                            = rsrun@output_dir_name
#     results_list$rsr_plot_dir_name                                              = rsrun@plot_dir_name
#
#     #---------------------------------------------------------------------------
#
#     APP_scores_according_to_RS_marxan_sa =
#         compute_and_verify_APP_scores_according_to_RS (marxan_mvbest_df,
#
#                                                     app_num_spp)    #  Is "app" right for this?
#
#     APP_scores_according_to_bdpg =
#         compute_and_verify_APP_scores_according_to_bdpg (app_bpm,
#
#                                                     app_num_PUs,    #  Is "app" right for this?
#                                                         marxan_best_solution_PU_IDs,
#                                                         marxan_best_num_patches_in_solution,
#                                                         cor_num_patches_in_solution,
#                                                         spp_rep_targets,
#                                                     app_num_spp,    #  Is "app" right for this?
#                                                         DEBUG_LEVEL,
#                                                         FP_const_rate,
#                                                         FN_const_rate)
#
#     #---------------------------------------------------------------------------
#
#     results_list = c (results_list,
#                       APP_scores_according_to_RS_marxan_sa,
#                       APP_scores_according_to_bdpg)
#
#     #---------------------------------------------------------------------------
#
# cat ("\n\nAt end of gscp_15, just before call to write_results_to_files():\n")
# #browser()
#
#     write_results_to_files (as.data.frame (results_list),
#                             parameters,
#                             get_RSprob_path_topdir (rsprob, exp_root_dir)
#                             # , cur_result_row    #  Added 2016 03 28 - BTL.
#                             )
#     }

#===============================================================================

#  The old call to create_master_output_structure() in bdprobdiff pkg inside
#  function do_marxan_analysis_and_output():
#
  # create_master_output_structure (
  #                         read_Xu_problem_from_Xu_file,
  #                         Xu_parameters,
  #
  #             #  These used to say just num_spp and num_PUs.
  #             #  For the moment, I'm going to make them cor_...
  #             #  since there is neither num_spp nor app_num_spp, etc.
  #             #  This needs fixing though.
  #                                       #num_PUs,  #  cor_num_PUs?  app_num_PUs?
  #                                       #num_spp,  #  cor_num_spp?  app_num_spp?
  #                         cor_num_PUs,  #  cor_num_PUs?  app_num_PUs?
  #                         cor_num_spp,  #  cor_num_spp?  app_num_spp?
  #
  #                         cor_optimum_cost,
  #
  #             #  Using cor_nodes for now
  #                                     #nodes,  #  cor_nodes?  app_nodes?
  #                         cor_nodes,
  #
  #                         cor_final_link_counts_for_each_node,
  #                         app_bpm,
  #                         DEBUG_LEVEL,
  #                         cor_bpm,
  #                         parameters,
  #                         add_error,
  #                         match_error_counts,
  #                         FP_const_rate,
  #                         FN_const_rate,
  #                         original_FP_const_rate,
  #                         original_FN_const_rate,
  #
  #                         marxan_control_values$spf_const,
  # #                        spf_const,
  #
  #                         app_bipartite_metrics_from_bipartite_package,
  #                         app_bipartite_metrics_from_igraph_package_df,
  #
  #                         app_marxan_output_values$marxan_best_df_sorted,
  #                         app_marxan_output_values$marxan_ssoln_df,
  #                         app_marxan_output_values$marxan_mvbest_df,
  #
  #                         marxan_control_values$marxan_PROP,
  #                         marxan_control_values$marxan_RANDSEED,
  #                         marxan_control_values$marxan_NUMREPS,
  #                         marxan_control_values$marxan_NUMITNS,
  #                         marxan_control_values$marxan_STARTTEMP,
  #                         marxan_control_values$marxan_NUMTEMP,
  #                         marxan_control_values$marxan_COSTTHRESH,
  #                         marxan_control_values$marxan_THRESHPEN1,
  #                         marxan_control_values$marxan_THRESHPEN2,
  #                         marxan_control_values$marxan_RUNMODE,
  #                         marxan_control_values$marxan_MISSLEVEL,
  #                         marxan_control_values$marxan_ITIMPTYPE,
  #                         marxan_control_values$marxan_HEURTYPE,
  #                         marxan_control_values$marxan_CLUMPTYPE
  #                                             )

#===============================================================================
#===============================================================================
#===============================================================================
#===============================================================================
#===============================================================================
#===============================================================================
#===============================================================================
#===============================================================================
#===============================================================================
#===============================================================================
#===============================================================================

{

        #  OLD CODE FOR COR - FROM BDPROBDIFF.
        #  This is just here to give context for how create_master...()
        #  was called, particularly, in terms of what the arguments were.

# #===============================================================================
# #                   Save the values for the "correct" problem.
# #===============================================================================
#
#     #  The problem structures built so far represent the correct values.
#     #  Adding error to the problem structure will create an apparent
#     #  problem structure that is probably different from the correct
#     #  structure.
#     #  When we compute scores at the end of all this, we need to compute
#     #  them with respect to the correct problem rather than the apparent.
#     #  So, before we add error, we need to save the values defining the
#     #  correct structure.
#
# cor_PU_spp_pair_indices = bdprob@PU_spp_pair_indices
# cor_bpm                 = bdprob@bpm
# cor_num_PUs             = bdprob@num_PUs
# cor_num_spp             = bdprob@num_spp
# cor_nodes               = bdprob@nodes
# cor_optimum_cost        = bdprob@cor_optimum_cost  #  BUG?  HOW IS THIS LOADED FOR XU FROM FILE?
# cor_PU_costs            = bdprob@PU_costs
# PU_col_name             = bdprob@PU_col_name
# spp_col_name            = bdprob@spp_col_name
#
# cor_PU_IDs              = bdprob@all_PU_IDs
# cor_spp_IDs             = bdprob@all_spp_IDs
#
# cat ("\n\nAbout to set all_correct_node_IDs.\n")
# #browser()
#     #  Some nodes may be unusued in cor_nodes, particularly if building a
#     #  compound problem, e.g., if wrapping a distribution around a Xu problem.
#     #  Need to add them into this list since it will be used to index array
#     #  entries, you can't have any missing indices.
# #all_correct_node_IDs = cor_nodes$node_ID
# all_correct_node_IDs = 1:max(cor_nodes$node_ID)
#
# presences_col_name = "freq"
#
# #===============================================================================
#
# cor_or_app_subdir_name = "cor"
#
#         #  NOTE:  2016 06 12 - Need to add writing of flags resulting from
#         #                       reading Xu file, e.g., prob_generator_params_known.
#         #                       This is because learning alg downstream needs to
#         #                       know things like whether the generator's params
#         #                       are even known, so that it doesn't try to learn
#         #                       something from missing data.
#
# CALL TO do_graph...().  DEFN OF do_graph...() IS GIVEN BELOW.
# do_graph_and_marxan_analysis (cor_or_app_subdir_name,
#
#                                             #  input parameters
#                                           parameters,
#                                           emulating_tzar,
#                                           DEBUG_LEVEL,
#                                           #derived_bdpg_parameters,   #  BUG?  UNKNOWN FOR XU FROM FILE?
#                                           derived_bdpg_parameters$current_os,
#
#                                             #  parameters from gen prob.
# #                                          bdprob$derived_Xu_params,
#                                           bdprob@Xu_parameters,
#                                           bdprob@read_Xu_problem_from_Xu_file,
#
# #            PU_spp_pair_names,  #NO
#
#                                             #  From bdprob structure, i.e., results of gen prob routine
#                                           cor_num_spp,
#                                           cor_num_PUs,
#                                           cor_PU_spp_pair_indices,
#     cor_PU_IDs, #####!!!!!#####
#     cor_spp_IDs,  #####!!!!!#####
#                                           cor_bpm,
#
#                             cor_PU_costs,
#                                           cor_optimum_cost,
#                                           cor_nodes,
#                                           spp_col_name,
#                                           PU_col_name,
#
#                                             #  Immediately after bdprob struct vars above.
#                                           presences_col_name, #  hard-coded as "freq"
# #####!!!!!#####                                          all_correct_node_IDs,
#
#                                             #  Results of adding error.
#                                             cor_num_spp,
#                                             cor_num_PUs,
#                                           cor_PU_spp_pair_indices,
#                                           cor_bpm,
#
#                                             #  input parameters for error model.
#                                           add_error=FALSE,
#                                           match_error_counts=FALSE,
#                                           FP_const_rate=0,
#                                           FN_const_rate=0,
#                                           original_FP_const_rate=0,
#                                           original_FN_const_rate=0
#                                           )


# DEFN OF do_graph...().  CALL TO do_graph...() IS GIVEN ABOVE.
# #===============================================================================
#
#         #  NOTE:  2016 06 12 - Need to add writing of flags resulting from
#         #                       reading Xu file, e.g., prob_generator_params_known.
#         #                       This is because learning alg downstream needs to
#         #                       know things like whether the generator's params
#         #                       are even known, so that it doesn't try to learn
#         #                       something from missing data.
#
# do_graph_and_marxan_analysis <- function (cor_or_app_subdir_name,
#
#                                             #  input parameters
#                                           parameters,
#                                           emulating_tzar,
#                                           DEBUG_LEVEL,
#
#                                           current_os,   #### derived_bdpg_parameters$current_os
#                                           #derived_bdpg_parameters,  # only used to get dirs and current_os, so should separate those out !!
#
#                                             #  parameters from gen prob.
#                                             #  They're only used in creating
#                                             #  the master output structure.
#                                           Xu_parameters,
#                                           read_Xu_problem_from_Xu_file,
#
#                                             #  From bdprob structure, i.e., results of gen prob routine
#                                           cor_num_spp,
#                                           cor_num_PUs,
#                                           cor_PU_spp_pair_indices,
#     cor_PU_IDs, #####!!!!!#####
#     cor_spp_IDs,  #####!!!!!#####
#                                           cor_bpm,
#
#                             cor_PU_costs,
#                                           cor_optimum_cost,
#                                           cor_nodes,
#                                           spp_col_name,
#                                           PU_col_name,
#
#                                             #  Immediately after bdprob struct vars above.
#                                           presences_col_name, #  hard-coded as "freq"
# #####!!!!!#####                                          all_correct_node_IDs,
#
#                                             #  Results of adding error.
#                                             app_num_spp,
#                                             app_num_PUs,
#                                           app_PU_spp_pair_indices,
#                                           app_bpm,
#
#                                             #  input parameters for error model.
#                                             #  Only used to create master output structure?
#                                           add_error,
#                                           match_error_counts,
#                                           FP_const_rate,
#                                           FN_const_rate,
#                                           original_FP_const_rate,
#                                           original_FN_const_rate
#                                           )
# {
# derived_bdpg_dir_names = create_dir_structure (cor_or_app_subdir_name)
# ...
# }




create_COR_master_output_structure <- function (marxan_control_values,
                                        marxan_output_values,
                                        parameters,

                                        COR_bd_prob,
                                        COR_marxan_run
                                        )
{
#xxxxx
#===============================================================================
#                   Dump all of the different kinds of results.
#===============================================================================


        #  NOTE:  2016 06 12 - Need to add writing of flags resulting from
        #                       reading Xu file, e.g., prob_generator_params_known.
        #                       This is because learning alg downstream needs to
        #                       know things like whether the generator's params
        #                       are even known, so that it doesn't try to learn
        #                       something from missing data.

  create_master_output_structure (
                          read_Xu_problem_from_Xu_file,
                          Xu_parameters,

              #  These used to say just num_spp and num_PUs.
              #  For the moment, I'm going to make them cor_...
              #  since there is neither num_spp nor app_num_spp, etc.
              #  This needs fixing though.
                                        #num_PUs,  #  cor_num_PUs?  app_num_PUs?
                                        #num_spp,  #  cor_num_spp?  app_num_spp?
                          cor_num_PUs,  #  cor_num_PUs?  app_num_PUs?
                          cor_num_spp,  #  cor_num_spp?  app_num_spp?

                          cor_optimum_cost,

              #  Using cor_nodes for now
                                      #nodes,  #  cor_nodes?  app_nodes?
                          cor_nodes,

                          cor_final_link_counts_for_each_node,
                          app_bpm,
                          DEBUG_LEVEL,
                          cor_bpm,
                          parameters,
                          add_error,
                          match_error_counts,
                          FP_const_rate,
                          FN_const_rate,
                          original_FP_const_rate,
                          original_FN_const_rate,

                          marxan_control_values$spf_const,
  #                        spf_const,

                          app_bipartite_metrics_from_bipartite_package,
                          app_bipartite_metrics_from_igraph_package_df,

                          app_marxan_output_values$marxan_best_df_sorted,
                          app_marxan_output_values$marxan_ssoln_df,
                          app_marxan_output_values$marxan_mvbest_df,

                          marxan_control_values$marxan_PROP,
                          marxan_control_values$marxan_RANDSEED,
                          marxan_control_values$marxan_NUMREPS,
                          marxan_control_values$marxan_NUMITNS,
                          marxan_control_values$marxan_STARTTEMP,
                          marxan_control_values$marxan_NUMTEMP,
                          marxan_control_values$marxan_COSTTHRESH,
                          marxan_control_values$marxan_THRESHPEN1,
                          marxan_control_values$marxan_THRESHPEN2,
                          marxan_control_values$marxan_RUNMODE,
                          marxan_control_values$marxan_MISSLEVEL,
                          marxan_control_values$marxan_ITIMPTYPE,
                          marxan_control_values$marxan_HEURTYPE,
                          marxan_control_values$marxan_CLUMPTYPE
                                              )


#xxxxx
    }

#===============================================================================

        #  OLD CODE FOR APP - FROM BDPROBDIFF.
        #  This is just here to give context for how create_master...()
        #  was called, particularly, in terms of what the arguments were.

# #===============================================================================
# #                   Add error to the species occupancy data.
# #===============================================================================
#
# add_error = FALSE
# if (! is.null (parameters$add_error_to_spp_occupancy_data))
#     add_error = parameters$add_error_to_spp_occupancy_data
#
# if (add_error)
#     {
#     ret_vals_from_add_errors =
#         add_error_to_spp_occupancy_data (parameters, cor_bpm,
#                                          cor_num_PU_spp_pairs,
#                                          cor_num_PUs, cor_num_spp,
#                                          bdpg_error_codes)
#
#         #  Save the chosen error parameters to output later with results.
#     original_FP_const_rate = ret_vals_from_add_errors$original_FP_const_rate
#     original_FN_const_rate = ret_vals_from_add_errors$original_FN_const_rate
#     match_error_counts     = ret_vals_from_add_errors$match_error_counts
#     FP_const_rate          = ret_vals_from_add_errors$FP_const_rate
#     FN_const_rate          = ret_vals_from_add_errors$FN_const_rate
#     app_num_spp            = ret_vals_from_add_errors$app_num_spp
#     app_num_PUs            = ret_vals_from_add_errors$app_num_PUs
#
#         #  Set the values for the apparent problem structure.
#     app_PU_spp_pair_indices      = ret_vals_from_add_errors$app_PU_spp_pair_indices
#     app_bpm                      = ret_vals_from_add_errors$app_spp_occupancy_data
#
# #=================================
#
#         #  Create subdirectory name for this apparent problem.
#         #  In the future, we may allow more than 1 app per cor, so
#         #  I'll add an app count to the end of the subdirectory name and
#         #  nest it under a more general "app" directory that corresponds to
#         #  the "cor" directory.
#
#     cur_app_num = 1
#     cor_or_app_subdir_name = paste0 ("app", .Platform$file.sep, "app.", cur_app_num)
#
#     do_graph_and_marxan_analysis (cor_or_app_subdir_name,
#
#                                                 #  input parameters
#                                               parameters,
#                                               emulating_tzar,
#                                               DEBUG_LEVEL,
#                                               #derived_bdpg_parameters,   #  BUG?  UNKNOWN FOR XU FROM FILE?
#                                               derived_bdpg_parameters$current_os,
#
#                                                 #  parameters from gen prob.
# #                                              bdprob$derived_Xu_params,
#                                               bdprob@Xu_parameters,
#                                               bdprob@read_Xu_problem_from_Xu_file,
#
#     #            PU_spp_pair_names,  #NO
#
#                                                 #  From bdprob structure, i.e., results of gen prob routine
#                                               cor_num_spp,
#                                               cor_num_PUs,
#                                               cor_PU_spp_pair_indices,
#     cor_PU_IDs, #####!!!!!#####
#     cor_spp_IDs,  #####!!!!!#####
#                                               cor_bpm,
#
#                             cor_PU_costs,
#                                               cor_optimum_cost,
#                                               cor_nodes,
#                                               spp_col_name,
#                                               PU_col_name,
#
#                                                 #  Immediately after bdprob struct vars above.
#                                               presences_col_name, #  hard-coded as "freq"
# #####!!!!!#####                                              all_correct_node_IDs,
#
#                                                 #  Results of adding error.
#                                                 app_num_spp,
#                                                 app_num_PUs,
#                                               app_PU_spp_pair_indices,
#                                               app_bpm,
#
#                                                 #  input parameters for error model.
#                                               add_error,
#                                               match_error_counts,
#                                               FP_const_rate,
#                                               FN_const_rate,
#                                               original_FP_const_rate,
#                                               original_FN_const_rate
#                                               )
#     } #####else    #  Don't add error.
# #     {         #  Since no error is being added, correct and apparent are the same.
# #
# #     app_PU_spp_pair_indices      = cor_PU_spp_pair_indices
# #     app_bpm                      = cor_bpm
# #     }

#-------------------------------------------------------------------------------

    #----------------------------
    #  Inputs to create master:
    #----------------------------

        #  Problem generator parameters

# Xu_parameters

        #  Reserve selector inputs and outputs

    #  Need to make these work for something other than just marxan_sa,
    #  so that it's easy to plug in zonation emulator and/or linear programming.
    #  To do that, need to look more closely at exactly the questions that
    #  you want to ask at the end, so that you know which values are crucial.
    #  You'll still have to learn separate predictors for each kind of
    #  reserve selector because input controls like marxan's number of of
    #  iterations affect output error.
    #  Still, another interesting question could be what you're able to predict
    #  across all different reserve selectors, i.e., are some problems harder
    #  than others for everyone?  That might be phrased as error(prob_A) >
    #  error(prob_B) for all reserve selectors...

# marxan_control_values
# app_marxan_output_values

        #  Network measures

# app_bipartite_metrics_from_bipartite_package
# app_bipartite_metrics_from_igraph_package_dfy

        #  Output scores

# ???

#-------------------------------------------------------------------------------

                                        #  Guessing at these args for now...
create_APP_master_output_structure <- function (marxan_control_values,
                                        marxan_output_values,
                                        parameters,

                                        COR_bd_prob,
                                        APP_bd_prob,
                                        APP_marxan_run
                                        )
{
}
}

#===============================================================================
#===============================================================================
#===============================================================================
#===============================================================================
#===============================================================================
#===============================================================================
#===============================================================================
#===============================================================================
#===============================================================================
#-------------------------------------------------------------------------------

# build_and_write_REP_scores_list <- function (  #rsrun,
#                                              marxan_mvbest_df,
#                                              marxan_best_df_sorted,
#                                              num_spp,
#                                              cor_bpm,
#                                              app_bpm,
#                                              spp_rep_targets)
#     {
# #    results_list = list (rep1=500, rep2=501, rep3=502)
#
# #    document_solutions_df ()
#
#
# #  read marxan output files before calling this routine (to get mvbest)?
#
#
#         #  Find which PUs the reserve selector (marxan only, for now)
#         #  chose for its best solution.
#
#     rs_best_solution_PU_IDs = which (marxan_best_df_sorted$SOLUTION > 0)
#
#     app_rs_solution_summary_scores_list =
#         summarize_RS_solution_scores (rs_best_solution_PU_IDs)
#
#     #----------
#
#     cor_rep_scores_list_according_to_bdpg =
#         compute_and_verify_APP_rep_scores_according_to_bdpg (cor_bpm,
#                                                              rs_best_solution_PU_IDs,
#                                                              spp_rep_targets,
#                                                              num_spp)
#
#     app_rep_scores_list_according_to_bdpg =
#         compute_and_verify_APP_rep_scores_according_to_bdpg (app_bpm,
#                                                              rs_best_solution_PU_IDs,
#                                                              spp_rep_targets,
#                                                              num_spp)
#
#     #----------
#
#     app_rep_scores_list_according_to_RS =
#         compute_and_verify_APP_rep_scores_according_to_RS (marxan_mvbest_df,
#                                                            num_spp)
#
#     #----------
#
#     results_list = c (app_rs_solution_summary_scores_list,
#                       cor_rep_scores_list_according_to_bdpg,
#                       app_rep_scores_list_according_to_bdpg,
#                       app_rep_scores_list_according_to_RS)
#
#     return (results_list)
#     }

#-------------------------------------------------------------------------------

#     # confusion_matrix_based_scores_list           =
#     #     build_and_write_confusion_matrix_based_scores_list (rsrun,
#     #                                                         marxan_best_num_patches_in_solution,    #num_PUs_in_cand_solution,
#     #                                                         num_PUs,
#     #                                                         cor_num_patches_in_solution,            #num_PUs_in_optimal_solution,
#     #                                                         cor_rep_scores_list$frac_spp_covered,   #frac_spp_covered,
#     #                                                         app_rep_scores_list$frac_spp_covered,   #frac_spp_covered,
#     #                                                         FP_const_rate,                          #input_err_FP = 0,
#     #                                                         FN_const_rate
#     #                                                         )
#
# build_and_write_confusion_matrix_based_scores_list <-
#     function (rsrun,
#                 marxan_best_num_patches_in_solution,    #num_PUs_in_cand_solution,
#                 num_PUs,
#                 cor_num_patches_in_solution,            #num_PUs_in_optimal_solution,
#                 cor_frac_spp_covered,                   #cor_rep_scores_list$frac_spp_covered,  #frac_spp_covered,
#                 app_frac_spp_covered,                   #app_rep_scores_list$frac_spp_covered,  #frac_spp_covered,
#                 FP_const_rate,                          #input_err_FP = 0,
#                 FN_const_rate
#                 )
#     {
# #    results_list = list (cls1=400, cls2=401)
#
#     #----------
#
# # app_results_list = compute_solution_vector_scores (app_bpm = ref_spp_occ_matrix, ...
#
#     app_confusion_matrix_based_error_measures_list =
#         compute_confusion_matrix_based_scores (marxan_best_num_patches_in_solution,    #num_PUs_in_cand_solution,
#                                                 num_PUs,
#                                                 cor_num_patches_in_solution,           #num_PUs_in_optimal_solution,
#                                                 app_rep_scores_list$frac_spp_covered,  #frac_spp_covered,
#                                                 FP_const_rate,                         #input_err_FP = 0,
#                                                 FN_const_rate                          #input_err_FN = 0,
#                                                )
#
#     #----------
#
#     results_list = c (cor_confusion_matrix_based_error_measures_list,
#                       app_confusion_matrix_based_error_measures_list
#                      )
#
#     return (results_list)
#     }
#
#     #----------
#
# # app_results_list = compute_solution_vector_scores (app_bpm = ref_spp_occ_matrix, ...
#
#     app_confusion_matrix_based_error_measures_list =
#         compute_confusion_matrix_based_scores (marxan_best_num_patches_in_solution,    #num_PUs_in_cand_solution,
#                                                 num_PUs,
#                                                 cor_num_patches_in_solution,           #num_PUs_in_optimal_solution,
#                                                 app_rep_scores_list$frac_spp_covered,  #frac_spp_covered,
#                                                 FP_const_rate,                         #input_err_FP = 0,
#                                                 FN_const_rate                          #input_err_FN = 0,
#                                                )

#-------------------------------------------------------------------------------

#         # build_and_write_COR_scores_list (
#         # cor_bpm, rs_best_solution_PU_IDs, spp_rep_targets, num_spp,
#         # marxan_best_num_patches_in_solution, num_PUs,
#         # cor_num_patches_in_solution, cor_rep_scores_list,
#         # FP_const_rate, FN_const_rate)
#
# build_and_write_COR_scores_list <-
#     function (rsrun,
#                 marxan_best_num_patches_in_solution,    #num_PUs_in_cand_solution,
#                 num_PUs,
#                 cor_num_patches_in_solution,            #num_PUs_in_optimal_solution,
#                 cor_frac_spp_covered,                   #cor_rep_scores_list$frac_spp_covered,  #frac_spp_covered,
#                 app_frac_spp_covered,                   #app_rep_scores_list$frac_spp_covered,  #frac_spp_covered,
#                 FP_const_rate,                          #input_err_FP = 0,
#                 FN_const_rate
#                 )
#     {
# #    results_list = list (cls1=400, cls2=401)
#
#     #----------
#
#       cor_rep_scores_list_according_to_bdpg =
#   #        compute_and_verify_APP_rep_scores_according_to_bdpg (cor_bpm,
#           compute_and_verify_COR_rep_scores_according_to_bdpg (cor_bpm,
#                                                                rs_best_solution_PU_IDs,
#                                                                spp_rep_targets,
#                                                                num_spp)
#
#       #----------
#
#   # cor_results_list = compute_solution_vector_scores (cor_bpm = ref_spp_occ_matrix, ...
#
#
#       cor_confusion_matrix_based_error_measures_list =
#           compute_confusion_matrix_based_scores (marxan_best_num_patches_in_solution,                      #num_PUs_in_cand_solution,
#                                                   num_PUs,
#                                                   cor_num_patches_in_solution,                             #num_PUs_in_optimal_solution,
#                                                   cor_rep_scores_list_according_to_bdpg$frac_spp_covered,  #frac_spp_covered,
#                                                   FP_const_rate,                                           #input_err_FP = 0,
#                                                   FN_const_rate                                            #input_err_FN = 0,
#                                                  )
#
#     #----------
#
#     results_list = c (cor_rep_scores_list_according_to_bdpg,
#                       cor_confusion_matrix_based_error_measures_list
#                      )
#
#     return (results_list)
#     }
#
# #-------------------------------------------------------------------------------
#
# build_and_write_APP_scores_list <-
#     function (rsrun,
#               app_bpm,
#               rs_best_solution_PU_IDs,
#               spp_rep_targets,
#               num_spp,
#               marxan_best_num_patches_in_solution,     #num_PUs_in_cand_solution,
#               num_PUs,
#               cor_num_patches_in_solution,             #num_PUs_in_optimal_solution,
#               app_rep_scores_list,
#               FP_const_rate,
#               FN_const_rate
#               )
#
#         # rsrun,
#         #         marxan_best_num_patches_in_solution,    #num_PUs_in_cand_solution,
#         #         num_PUs,
#         #         cor_num_patches_in_solution,            #num_PUs_in_optimal_solution,
#         #         app_frac_spp_covered,                   #app_rep_scores_list$frac_spp_covered,  #frac_spp_covered,
#         #         FP_const_rate,                          #input_err_FP = 0,
#         #         FN_const_rate
#                 # )
#     {
#   #    results_list = list (cls1=400, cls2=401)
#
#       #----------
#
#       app_rep_scores_list_according_to_bdpg =
#           compute_and_verify_APP_rep_scores_according_to_bdpg (app_bpm,
#                                                                rs_best_solution_PU_IDs,
#                                                                spp_rep_targets,
#                                                                num_spp)
#
#       #----------
#
#   # app_results_list = compute_solution_vector_scores (app_bpm = ref_spp_occ_matrix, ...
#
#       app_confusion_matrix_based_error_measures_list =
#           compute_confusion_matrix_based_scores (marxan_best_num_patches_in_solution,                      #num_PUs_in_cand_solution,
#                                                   num_PUs,
#                                                   cor_num_patches_in_solution,                             #num_PUs_in_optimal_solution,
#                                                   app_rep_scores_list_according_to_bdpg$frac_spp_covered,  #frac_spp_covered,
#                                                   FP_const_rate,                                           #input_err_FP = 0,
#                                                   FN_const_rate                                            #input_err_FN = 0,
#                                                  )
#
#     #----------
#
#     results_list = c (app_rep_scores_list_according_to_bdpg,
#                       app_confusion_matrix_based_error_measures_list
#                      )
#
#     return (results_list)
#     }
#
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------

#===============================================================================

#  2017 08 22 - BTL - Every call to this is commented out, so I think it's
#                     vestigial.
create_master_output_structure <-
        function (read_Xu_problem_from_Xu_file,

                    Xu_parameters,  #  most param values for problem

                    num_PUs,
                    num_spp,
                    cor_optimum_cost,
                    nodes,
                    cor_final_link_counts_for_each_node,
                    bpm,
                    DEBUG_LEVEL,
                    cor_bpm,
                    parameters,
                    add_error,
                    match_error_counts,
                    FP_const_rate,
                    FN_const_rate,
                    original_FP_const_rate,
                    original_FN_const_rate,
                    spf_const,
                    bipartite_metrics_from_bipartite_package,
                    bipartite_metrics_from_igraph_package_df,

                    marxan_best_df_sorted,
                    marxan_ssoln_df,
                    marxan_mvbest_df,
                    marxan_PROP,
                    marxan_RANDSEED,
                    marxan_NUMREPS,
                    marxan_NUMITNS,
                    marxan_STARTTEMP,
                    marxan_NUMTEMP,
                    marxan_COSTTHRESH,
                    marxan_THRESHPEN1,
                    marxan_THRESHPEN2,
                    marxan_RUNMODE,
                    marxan_MISSLEVEL,
                    marxan_ITIMPTYPE,
                    marxan_HEURTYPE,
                    marxan_CLUMPTYPE
                    )
{
derived_Xu_params    = Xu_parameters@derived_params
base_Xu_params       = Xu_parameters@base_params
bdpg_extended_params = Xu_parameters@bdpg_extended_params

#-------------------------------------------------------------------------------
#      Initialize the data frame holding correct and apparent solutions.
#-------------------------------------------------------------------------------

      #---------------------------------------------------------------------
      #  Need to separate the case of reading a Xu problem from one of
      #  his benchmark files vs. generating a problem from scratch.
      #  When you read it from a benchmark file, the correct solution cost
      #  is known, but not the correct solution vector.
      #  So, when reading a problem from a benchmark file, initialize all
      #  kinds of things to NA.
      #---------------------------------------------------------------------

  if (read_Xu_problem_from_Xu_file)
      {
      save_rsprob_results_data_for_Xu_read_from_bench_file ()

      } else  #  generated the problem
      {
      save_rsprob_results_data_for_Xu_NOT_read_from_bench_file ()
      }

  #===============================================================================
  #       Compute correct and apparent scores for marxan solution.
  #===============================================================================

  cat ("\n\nnum_spp =", num_spp)
  spp_rep_targets = rep (1, num_spp)    #  Seems like this should already have been set long before now.
                                        #  In fact, they are now a variable (called "targets") inside of the RSrun class structure.
                                        #  Are they ever set there?
                                        #  ***  Actually, shouldn't targets be part of the RSprob instead of RSrun,
                                        #       i.e., the targets are part of what makes a problem hard or easy.
                                        #       They're also a basic structuring assumption in building the Xu
                                        #       problems.  ***

    document_solutions_df ()
    summarize_RS_solution_scores ()
    compute_and_verify_APP_scores_according_to_RS ()
    compute_and_verify_APP_scores_according_to_bdpg ()
    compute_and_verify_COR_scores_according_to_bdpg ()

  #===============================================================================

  #  Supporting data not in binding
  #   species vs planning units (database?) to allow computation of performance
  #   measures related to which species are covered in solutions
  #   (e.g., SELECT species WHERE planning unit ID == curPlanningUnitID)
  #   (e.g., SELECT planning unit ID WHERE species == curSpeciesID))
  #       - planning unit IDs
  #       - set of species on planning unit

  #     ALSO STILL NEED TO ADD THE FP AND FN RATES AND OTHER ERROR MODEL
  #     ATTRIBUTES TO THE OUTPUT DATA FRAME AND CSV FILE.
  #             2017 05 01 - Is this still true?

  #-------------------------------------------------------------------------------

  num_runs = 1    #  Vestigial?  Not sure it will ever be anything but 1.
                  #  2015 05 09 - BTL.

  results_list <- initialize_results_list ()

  cur_result_row = 0

  #-------------------------------------------------------------------------------

  cur_result_row = cur_result_row + 1

      #  Filling in the runset_abbrev with the full runset name for the moment,
      #  because it's more reliably correct since it's automatically captured
      #  by tzar.  Not sure what I'll do in the long run.
      #  2015 03 09 - BTL
  results_list$runset_abbrev                                                     = parameters$runset_name    #  parameters$runset_abbrev
  results_list$runset_name                                                       = parameters$runset_name

  results_list$exceeded_thresh_for_num_spp                                       = FALSE

  #-------------------------------------------------------------------------------

    compute_and_verify_APP_scores_according_to_bdpg ()
    compute_and_verify_COR_scores_according_to_bdpg ()
    compute_and_verify_APP_scores_according_to_RS ()

    save_RS_options ()

  #-------------------------------------------------------------------------------

  #  Getting an error.  Not sure why...  Is it because the free variable names
  #  like num_PUs, are the same as the list element names, like results_list$num_PUs?
  #
  #  Error in `$<-.data.frame`(`*tmp*`, "num_PUs", value = c(NA, 12L)) :
  #    replacement has 2 rows, data has 1
  #  Calls: source ... withVisible -> eval -> eval -> $<- -> $<-.data.frame
  #  Execution halted


  if (parameters$compute_network_metrics)
      {
          #  Need to bind the network measures to the data frame too.
#  2017 05 01 - BTL
#  Are these graph metrics only computed over the correct problem or
#  only over the apparent problem?
#  Seems like both may be important to know for prediction.
      results_list = cbind (results_list,
                          bipartite_metrics_from_bipartite_package,
                          bipartite_metrics_from_igraph_package_df
                          )
      }

  write_results_to_files (results_list, parameters,
                          cur_result_row)    #  Added 2016 03 28 - BTL.
}

#===============================================================================



