% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/std_param_defns.R
\name{std_param_defns}
\alias{std_param_defns}
\title{Standardized parameter definitions for reuse across all functions}
\usage{
std_param_defns(bdpg_error_codes, bdpg_error_name, bpm,
  correct_solution_vector_is_known, dependent_node_IDs, duplicate_links_allowed,
  edge_list, integerize, integerize_string, max_allowed_num_spp,
  max_possible_tot_num_links, n__num_groups, nodes, num_nodes_per_group,
  num_PUs, num_rounds_of_linking_between_groups, num_spp, occ_matrix,
  parameters, PU_col_name, PU_costs, PU_set_to_test, PU_spp_pair_indices,
  spp_col_name, spp_rep_fracs, spp_rep_targets,
  spp_rows_by_PU_cols_matrix_of_spp_cts_per_PU,
  target_num_links_between_2_groups_per_round)
}
\arguments{
\item{bdpg_error_codes}{list of error names and corresponding error codes}

\item{bdpg_error_name}{string containing name of error code to look up in
list of error codes}

\item{bpm}{bipartite matrix; integer matrix with one row for each species
and one column for each planning unit.  Each matrix entry specifies
whether that species occupies that planning unit; 1 indicates the
species does occupy the planning unit and 0 indicates it does not.
Same as occ_matrix.}

\item{correct_solution_vector_is_known}{boolean flag indicating whether
a correct optimal solution vector is known for the problem (as opposed
for example, to only knowing the correct cost)}

\item{dependent_node_IDs}{integer vector of IDs of planning units contained
in a constructed correct solution to a Xu problem}

\item{duplicate_links_allowed}{boolean indicating whether more than one link
is allowed between the same two planning units, i.e., whether more than
one species can occupy exactly the same pair of planning units; TRUE
implies more than one allowed, FALSE implies only one allowed}

\item{edge_list}{two column integer matrix of node IDs with one row for
each edge and columns for the 2 ends of the edge}

\item{integerize}{function to use in converting floats to ints}

\item{integerize_string}{string containing name of the function to use to
convert floats to integers}

\item{max_allowed_num_spp}{integer maximum number of species allowed in the
problem (to keep from generating problems that are too large when trying
to keep the run-time down)}

\item{max_possible_tot_num_links}{integer maximum possible number of links
in the Xu problem given all the other parameter settings}

\item{n__num_groups}{integer number of groups in the Xu problem, one of the
4 base input parameters for specifying the Xu problem}

\item{nodes}{data frame containing integer node_ID, integer group_ID, and boolean dependent_set_member}

\item{num_nodes_per_group}{integer number of planning units per group in the
Xu problem}

\item{num_PUs}{integer number of planning units}

\item{num_rounds_of_linking_between_groups}{integer number of rounds of
linking to be done between groups in constructing the Xu problems}

\item{num_spp}{integer number of species in the problem}

\item{occ_matrix}{occupancy matrix, integer matrix with one row for each
species and one column for each planning unit.  Each matrix entry
specifies whether that species occupies that planning unit; 1 indicates
the species does occupy the planning unit and 0 indicates it does not.
Same as bpm.}

\item{parameters}{parameters list for the run, usually derived from project.yaml
and can have a varying number and set of elements depending on the run}

\item{PU_col_name}{character string giving planning unit column name in data frames}

\item{PU_costs}{numeric vector of planning unit costs}

\item{PU_set_to_test}{integer vector of planning unit IDs where each ID
specifies a planning unit to include in the set to be tested}

\item{PU_spp_pair_indices}{data frame with 2 integer columns, PU_ID and
spp_ID, where each row identifies a the ID of a given species that
occurs on the given planning unit}

\item{spp_col_name}{character string giving species column name in data frames}

\item{spp_rep_fracs}{numeric vector of fractions of species
representation targets achieved by a given set of planning units}

\item{spp_rep_targets}{numeric vector with a target abundance for each
species in the problem}

\item{spp_rows_by_PU_cols_matrix_of_spp_cts_per_PU}{integer matrix of
abundance of each species in each planning unit, with a row for each
species ID and a column for each planning unit ID}

\item{target_num_links_between_2_groups_per_round}{integer target number of
links between any two groups per round of linking in constructing the
Xu problem}
}
\description{
This function should \emph{never} be called.  It is intended strictly as a
place to assemble all @param values that are to be inherited by other
functions in their Roxygen documentation.
}
\details{
In general, when you're documenting a function's parameters using Roxygen and
the same parameter is defined for multiple routines, you're supposed to use
\code{@inheritParams} and point to one other function as the single source
of that parameter's definition.  That doesn't work well for me because often,
the function that you want to inherit from:
     \enumerate{
      \item{has \emph{some} of the variables you want to inherit, and/or}
      \item{is \emph{missing} others, and/or}
      \item{has \emph{irrelevant} variables that you want to ignore, or}
      \item{has some \emph{combination} of the above and you have to inherit
            from multiple functions to get some subset of params from
            all of them and it becomes difficult to guess which param
            definition is drawn from which other function.}
      }

There is no designation of what is \emph{the} canonical base function
for all copies of a particular \code{@param} that gets inherited.
Consequently, if you don't realize that something depends on a function
used in an \code{@inheritParams} command somewhere in your code
and you delete or rename the function, or delete or rename an inherited
argument, you can break downstream documentation.

It would be better to have a designated data dictionary where all of these
standardized things can be assembled and all \code{@inheritParams} can
point.  Since that doesn't exist, I'm making this dummy function that I will
use by convention as the one central place to copy parameter declarations
from when I want them.  However, the only way I can see to fool Roxygen into
doing this is by creating a dummy function that's never called and exists
solely to be the source of inherited parameter definitions.

There are some potential problems with this:
     \itemize{
      \item{It may have performance problems when Roxygen documentation is
            built since the list of parameters here will be long.  I have
            no idea whether that will be a problem or not.}
      \item{It doesn't solve the problem in point 3 above, i.e., it will
            have \emph{tons} of irrelevant variables for nearly every
            function that inherits from it.  Again, I don't know if there
            are any consequences of that.  Roxygen does properly ignore the
            irrelevant variables I think, but it still makes for a lot of
            mental noise for the person doing the documenting when they're
            looking at all these other functions and trying to sort out what
            is relevant and what isn't.  Hopefully, doing it as one giant
            alphabetical list in just one place makes it a little easier...}
      \item{I \emph{think} that you can override a parameter definition
            locally if you want a different local definition but say that
            you want to inherit params (e.g., to satisfy other variables in
            your parameter list), but I'm not absolutely certain of that at
            the moment.  If that doesn't work, it may be that you just have
            to rename the variable locally to avoid the conflict.}
            }
}
\section{Conventions}{

The main convention here will be to try to keep the parameters in
alphabetical order to make them easier to find and not duplicate.
}

\section{How to use}{

\describe{
          \item{To inherit an \code{@param} from here:}{In the Roxygen documentation
                for any function where you want to use a parameter definition from
                this list, you just include a statement saying:

                \code{#' @inheritParams std_param_defns}
               }
          \item{To add a parameter \code{x} to the list of params in the list here:}{
                \itemize{
                         \item{Insert the name \code{x} in alphabetical order
                               in the parameter list for the dummy function
                               \code{std_param_defns}.
                               }
                         \item{Insert "\code{@param x blah blah blah}" in
                               alphabetical order in the list of \code{@param}s in
                               the documentation for the dummy function
                               \code{std_param_defns}.
                               }
                         }
               }
         }
}

