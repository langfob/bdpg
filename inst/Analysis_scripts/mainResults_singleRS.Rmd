---
title: "BDPG main results for single Reserve Selector"
author: "Bill Langford"
date: "`r Sys.Date()`"
output:
  pdf_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 4
  html_notebook:
    toc: yes
    toc_depth: 4
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '4'
---

Need to fix:

- Missing plots of rep shortfall vs FRAC_spp_covered

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)    #, message=FALSE)
```

This file is cloned from mainResults.Rmd, which was getting too big and unwieldy and taking much too long to run.  In here, I will strip out all references to anything other than a single reserve selector.  The whole thing should be trivial to rerun for each different reserve selector by just changing the variable `rs_name`.

```{r setRSname}
#rs_name = "Gurobi"
rs_name = "Marxan_SA"
#rs_name = "Marxan_SA_SS"
#rs_name = "ZL_Backward"
#rs_name = "ZL_Forward"
#rs_name = "SR_Backward"
#rs_name = "SR_Forward"
#rs_name = "UR_Backward"
#rs_name = "UR_Forward"
```

This is just a quick and dirty summary of what I think are the main results that I want to put in the first paper.  I need this to pare down what I'm doing in the other documents.

#  Load necessary libraries

```{r message=FALSE}
    #  Note that "message=FALSE" is necessary for this chunk if you want to 
    #  generate pdfs.  When the tidyverse package is loaded, it writes puts 
    #  out a message that includes some unicode that the normal latex engine 
    #  (used to produce the pdf) can't handle and it crashes with the following 
    #  message:
    #       ! Package inputenc Error: Unicode character [sqrt symbol goes here] (U+221A)
    #       (inputenc)                not set up for use with LaTeX.
    #  Note that I've also had to remove the sqrt symbol from the error message 
    #  when embedding it in the comment here, because even inside the comment, 
    #  latex tried to render that and crashed.
    #  More information about this can be found at:
    #   - https://community.rstudio.com/t/tidyverse-1-2-1-knitting-to-pdf-issue/2880/4
    #   - https://community.rstudio.com/t/cant-render-tidyverse-1-2-startup-message-in-latex/2811/5
    #   - https://chrisbeeley.net/?p=1037

library (tidyverse)
```

#  Set file paths

```{r setFilePaths}
#===============================================================================

# # # base_path = "/Users/bill/D/Projects/ProblemDifficulty/Results/bdpg_20_variants_all_rs_easy_base/bdpg_20_variants_all_rs_easy_base_Combined_err_amts/"
# 
#     #  Easy
# base_path = "/Users/bill/D/Projects/ProblemDifficulty/Results/bdpg_20_variants_all_rs_easy_base_2nd_attempt/bdpg_20_variants_all_rs_easy_base_2nd_try_Combined_err_amts/"
# 
#     #  Hard
# base_path = "/Users/bill/D/Projects/ProblemDifficulty/Results/bdpg_20_variants_all_rs_HARD_base_first_attempt/bdpg_20_variants_all_rs_HARD_base_1st_try_Combined_err_amts/"

#     #  Hard - 2, 5, 7.5, 10 % error
# base_path = "/Users/bill/D/Projects/ProblemDifficulty/Results/bdpg_20_variants_all_rs_HARD_base_first_attempt/bdpg_20_variants_all_rs_HARD_base_02_05_075_10_Combined_err_amts/"


suffix = ".combined_results.csv"
```

-----   

#  Load data

-----   

##  Define functions to read and write input and output data

```{r loadInputData, include=FALSE}
#===============================================================================

load_input_data <- function (rs_name, base_path, suffix)
    {
    infile = paste0 (base_path, rs_name, suffix)

        #  I can't remember why I called these "msa".  It might stand for 
        #  multi-set analysis...
    
    df = read.csv (infile, header=TRUE, stringsAsFactors = FALSE)
    
    return (df)
    }

#===============================================================================

write_output_data <- function (df, rs_name, base_path, suffix)
    {
    outfile = paste0 (base_path, rs_name, suffix)
    cat ("\n\nIn write_output_data(), outfile = '", outfile, 
         "'\n", sep='')
    write.csv (df, outfile, row.names=FALSE)
    }

#===============================================================================

reduce_full_data_to_working_set <- function (full_df)
    {
    working_df = select (full_df, #c(
                      
            #  Problem and reserve selector labels                     
                    id,     #  Easy or Hard
            
                    rs_method_name, 
                    rsp_combined_err_label, 
                    rsp_cor_or_app_str, 
                    rsp_base_wrap_str, 
                    
                    # rsr_tzar_run_ID, 
                    # rsr_UUID, 
                    # 
                    # rsp_file_name_prefix, 
                    # 
                    # rsp_UUID, 
                    # rsp_UUID_of_base_problem_that_has_err_added, 
                    # rsp_UUID_of_base_problem_that_is_wrapped, 
    
    
            #  Input descriptors
                    rsp_num_PUs, 
                    rsp_num_spp, 
                    rsp_num_spp_per_PU, 
                    rsp_correct_solution_cost, 
            
                    sppPUsum,
                    sppPUprod, 
            
            #  Post-gen knowable problem descriptors
            
                #  Species and PU counts
                    rsp_app_num_spp, 
                    rsp_app_num_PUs, 
                    
                #  igraph package metrics
    #                ig_rsp_UUID, 
            
                    ig_top, 
                    ig_bottom, 
                    ig_num_edges_m, 
                    ig_ktop, 
                    ig_kbottom, 
                    ig_bidens, 
                    ig_lcctop, 
                    ig_lccbottom, 
                    ig_distop, 
                    ig_disbottom, 
                    ig_cctop, 
                    ig_ccbottom, 
                    ig_cclowdottop, 
                    ig_cclowdotbottom, 
                    ig_cctopdottop, 
                    ig_cctopdotbottom, 
                    ig_mean_bottom_bg_redundancy, 
                    ig_median_bottom_bg_redundancy, 
                    ig_mean_top_bg_redundancy, 
                    ig_median_top_bg_redundancy, 
                    
                    # ig_user_time, 
                    # ig_system_time, 
                    # ig_elapsed_time, 
                    # ig_user_child_time, 
                    # ig_sys_child_time, 
                                    
                #  bipartite package metrics
    #                bip_rsp_UUID, 
            
                    connectance, 
                    number.of.PUs, 
                    number.of.Spp, 
                    
                    # bip_user_time, 
                    # bip_system_time, 
                    # bip_elapsed_time, 
                    # bip_user_child_time, 
                    # bip_sys_child_time, 
    
    
                #  Possibly knowable realized input error values
                    rsp_realized_median_abs_cost_err_frac, 
                    rsp_realized_mean_abs_cost_err_frac, 
                    rsp_realized_sd_abs_cost_err_frac, 
                    rsp_FP_const_rate, 
                    rsp_FN_const_rate, 
                    
                    rsp_realized_FP_rate, 
                    rsp_realized_FN_rate, 
                    rsp_realized_Ftot_rate, 
                    rsp_euc_realized_FP_and_cost_in_err_frac, 
                    rsp_euc_realized_FN_and_cost_in_err_frac, 
                    rsp_euc_realized_Ftot_and_cost_in_err_frac, 
                    
                    rsp_wrap_is_imperfect,
                            
    
                #  Results and their errors
                    rs_solution_cost, 
                    rs_solution_cost_err_frac, 
                    abs_rs_solution_cost_err_frac, 
                    
                    rs_over_opt_cost_err_frac_of_possible_overcost, 
                    rs_under_opt_cost_err_frac_of_possible_undercost, 
                    
                    rsr_COR_euc_out_err_frac, 
                    
                            # rsr_APP_spp_rep_shortfall, 
                            # rsr_APP_solution_NUM_spp_covered, 
                            # rsr_APP_solution_FRAC_spp_covered, 

                    rsr_COR_spp_rep_shortfall, 
                    rsr_COR_solution_NUM_spp_covered, 
                    rsr_COR_solution_FRAC_spp_covered, 

    
    
    
        
                    err_mag
                    #, 
                    
                #  Reserve selector run times
                    # RS_user_time, 
                    # RS_system_time, 
                    # RS_elapsed_time, 
                    # RS_user_child_time, 
                    # RS_sys_child_time
                      )
#    )
    
    #--------------------
    
        #  Now, remove all COR and BASE problems to leave just he APP WRAPs.
    
    working_df %>%
        filter (rsp_cor_or_app_str == "APP" & 
                rsp_base_wrap_str == "Wrap" & 
                (rsp_combined_err_label == "02-FP_only_NO_cost_err" | 
                 rsp_combined_err_label == "03-FN_only_NO_cost_err" | 
                 rsp_combined_err_label == "04-FP_and_FN_matched_NO_cost_err" | 
                 rsp_combined_err_label == "05-FP_and_FN_not_matched_NO_cost_err")) -> working_df 
    
    return (working_df)
    }

```

##  Load combined Easy/Hard input data

```{r loadCombinedEasyAndHardInputData}

    #  Combined Easy and Hard (all Easy error levels, all Hard except 15%)
base_path = "/Users/bill/D/Projects/ProblemDifficulty/Results/FullEasyHardV1/cln_easyHard."

#----------

easyHard_df_Marxan_SA    = load_input_data ("Marxan_SA", base_path, suffix)
```

## Reduce the full data set down to a working set 

Reduce the data set to just APP WRAP problems and examples with no input cost error.

```{r reduceFullDataToWorkingSet}
working_df_Marxan_SA    = reduce_full_data_to_working_set (easyHard_df_Marxan_SA)
```

#  Plot the results

## Input error vs. output error

- Generated hard problems were much harder than generated easy problems, as predicted
- There is lots of variation in problem difficulty at every level of input error
- Solution quality under uncertainty is not good, regardless of optimizer
- Not much difference in reserve selectors  
    - Smoothers were slightly better in median (ZL and SA_SS)
- Possible difference for Simple Richness on difficult problem?
- Also need to add plots for all output error fractions values below 1.

### Define plotting functions for input error vs. output error 

```{r include=FALSE}
#===============================================================================

gg_eucInTot_vs_eucOutTot_all_on_1 <- function (rs_name,
                                               sorted_msa_tib,
                                               ref_y = 0
                                               
                                               , shape_type="."
                                               , alpha_level=1
                                               )
    {
ggplot (data = sorted_msa_tib) +
        aes(x = rsp_euc_realized_Ftot_and_cost_in_err_frac,
                                    y = rsr_COR_euc_out_err_frac,
        #                            color = rsp_combined_err_label)) +
#####                                    color = rsp_base_wrap_str) +
                                     color = id) +
# ##        geom_point() +
# #        geom_point(shape=".", alpha=1/10) +
         geom_point(shape=shape_type, alpha=alpha_level) +
# #        geom_point(shape=".") +
# #        geom_point(alpha=1/25) +


#             #                            color = rsp_combined_err_label)) +
# #                                         color = id
# #         ,
# #         shape="."
# #         ) +
# # ##            geom_point() +
# # #        geom_point(shape=".") +
# 
#                                     color = id) +
#         geom_point(shape=".", alpha=1) +

    



#####        scale_color_manual(breaks = c("Base", "Wrap"), values=c("red", "blue")) +
        scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +
        stat_smooth(method = "lm", col = "green") +

    # ggplot (data = sorted_msa_tib) +
    #       geom_point (mapping = ) +
    #     #scale_color_viridis(discrete=TRUE) +
    #     scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +
    #
        ggtitle (paste0 (rs_name, " - Total input error vs. Total output error")) +
        theme(plot.title = element_text(hjust = 0.5)) +    #  To center the title

          geom_hline (yintercept = ref_y, linetype="dashed",
                        color = "black", size=0.5) +
          geom_abline (intercept=0, slope=1  #, linetype, color, size
                       ) +
          geom_abline (intercept=0, slope=5  #, linetype, color, size
                       ) +
          geom_abline (intercept=0, slope=10  #, linetype, color, size
                       )
    }

#===============================================================================

gg_eucInTot_vs_eucOutTot_facetted_by_err_label <- function (rs_name,
                                                            sorted_msa_tib,
                                                            ref_y = 0
                                                            , shape_type = "."
                                                            , alpha_level = 1
                                                            )
    {
    ggplot (data = sorted_msa_tib) +
      geom_point (mapping = aes(x = rsp_euc_realized_Ftot_and_cost_in_err_frac,
                                y = rsr_COR_euc_out_err_frac,
    #                            color = rsp_combined_err_label)) +
    #                             color = id
    # ), 
    # shape="."
    # ) +
 # color = id
 #    ), 
 #    shape="."
 #    ) +
 color = id
    ), 
    shape="."
    ) +
        

    #scale_color_viridis(discrete=TRUE) +
    #scale_color_brewer(palette="Set1") +
    scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +

    ggtitle (paste0 (rs_name, " - Total input error vs. Total output error by Error Class")) +
    theme(plot.title = element_text(hjust = 0.5)) +    #  To center the title

      facet_wrap (~ rsp_combined_err_label, nrow = 5) +
      geom_hline (yintercept = ref_y, linetype="dashed",
                    color = "black", size=0.5) +
      geom_abline (intercept=0, slope=1  #, linetype, color, size
                   ) +
      geom_abline (intercept=0, slope=5  #, linetype, color, size
                   ) +
      geom_abline (intercept=0, slope=10  #, linetype, color, size
                   )
    }
```

### Plot the input error vs output error 

#### Full data set

```{r}

gg_eucInTot_vs_eucOutTot_all_on_1 ("Marxan_SA", easyHard_df_Marxan_SA, ref_y = 0
#                                   , shape_type = 1, alpha_level = 1
                                   )
```

#### Full data set, just values that are not huge errors

```{r}
easyHard_df_Marxan_SA %>% 
    filter (rsr_COR_euc_out_err_frac <= 1) -> easyHard_Marxan_SA_not_huge_out_err_df
gg_eucInTot_vs_eucOutTot_all_on_1 ("Marxan_SA", easyHard_Marxan_SA_not_huge_out_err_df, ref_y = 0
, shape_type = ".", alpha_level = 1
)

```

#### Working data set

Plot the same results for working data set that only includes APP WRAP problems that have no input cost error.  Note that this changes the scaling and the fit lines.

```{r}
gg_eucInTot_vs_eucOutTot_all_on_1 ("Marxan_SA", working_df_Marxan_SA, ref_y = 0
#, shape_type = 1, alpha_level = 1/20
                                   )
```

#### Working data set, just values that are not huge errors

```{r}
working_df_Marxan_SA %>% 
    filter (rsr_COR_euc_out_err_frac <= 1) -> working_Marxan_SA_not_huge_out_err_df
gg_eucInTot_vs_eucOutTot_all_on_1 ("Marxan_SA", working_Marxan_SA_not_huge_out_err_df, ref_y = 0
#, shape_type = ".", alpha_level = 1/20
                                   )
```

##  Error magnification

### Optimization often amplifies input error

Not sure this needs a separate plot, since the 10:1, 5:1, and 1:1 lines show it so well and the actual exact numbers aren't that important.

####  Show all magnification values first (to show full range)

```{r}
plot (working_df_Marxan_SA$rsp_euc_realized_Ftot_and_cost_in_err_frac, 
      working_df_Marxan_SA$err_mag, 
      main=paste0 ("Input error vs. Error Magnification\n", "Marxan_SA"), 
      xlab="Total Euc Input Error Frac",
      ylab="Err magnification")
```

####  Show all magnification values below 10

This gets rid of all the extreme values that result at tiny, tiny input errors.

```{r}
idxs_of_not_huge_err_mags = which (working_df_Marxan_SA$err_mag <= 10)
plot (working_df_Marxan_SA$rsp_euc_realized_Ftot_and_cost_in_err_frac [idxs_of_not_huge_err_mags], 
      working_df_Marxan_SA$err_mag [idxs_of_not_huge_err_mags], 
      main=paste0 ("Input error vs. Error Magnification (<= 10)\n", "Marxan_SA"), 
      xlab="Total Euc Input Error Frac",
      ylab="Err magnification")
```

##  Different types of input error produced different amounts of output error

- Uniform random cost error had almost no impact anywhere  
- FN produced ...  
- FP produced ...  
- Mixed was determined by FN or FP dominance  

```{r}
gg_eucInTot_vs_eucOutTot_facetted_by_err_label ("Marxan_SA", easyHard_df_Marxan_SA, ref_y = 0)
gg_eucInTot_vs_eucOutTot_facetted_by_err_label ("Marxan_SA", working_df_Marxan_SA, ref_y = 0)

# easyHard_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df
gg_eucInTot_vs_eucOutTot_facetted_by_err_label ("Marxan_SA", easyHard_Marxan_SA_not_huge_out_err_df, ref_y = 0)
# working_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df
gg_eucInTot_vs_eucOutTot_facetted_by_err_label ("Marxan_SA", working_Marxan_SA_not_huge_out_err_df, ref_y = 0)
```


##  Different types of output error

### Ascelin's comment about how much effort is each RS putting into getting the tail end of the species

- I think that I do have a kind of record of that in the cumulative plots I was putting out showing fraction of species covered on x and number of patches included (cost) on y.  I think those plots are still being generated.  Need to look.  It may be that some of them have an elbow that could be identified, but if there's no elbow, the choice of cutoff becomes more arbitrary.  
- Other possibilities might be:
    - fraction of species covered by only spending the optimal cost (i.e., consider that the budget)
    - fraction of species covered at various quantiles of cost (e.g., 90, 95, 99)
    - fraction of optimal cost for various quantiles of fraction of spp covered  (e.g., 90, 95, 99)
    - or just a simple invocation of the 80/20 rule in some way
        - I think that at one point, I was calculating the cost per spp covered at each step in the purchase sequence, but the maximum value of that occurs at the start of the process, so it's not that helpful  
        - then again, you could start throwing out PUs based on unprotected richness or something until you get down to the budget  
- One issue here is that when the non-greedy reserve selectors are running on the apparent data, they don't give you an ordering of the PUs and they're making mistakes _because_ they don't know they're making them, so you can only do some sort of correct pruning if you do know the correct answer.
        

###  Decompose output errors into over/under, etc

I've tracked the overcost and undercost and the underrepresentation (shortfall).  Maybe these can partly get at what Ascelin was asking about.  

#### Results and their errors  

- rs_solution_cost_err_frac 
- abs_rs_solution_cost_err_frac 

- rsr_COR_spp_rep_shortfall 
- rsr_COR_solution_FRAC_spp_covered 

```{r funcsGgplotSignedErrFracsAndRepShortfalls, include=FALSE}
#===============================================================================

gg_eucInTot_vs_signedCostErrFrac_all_on_1 <- function (rs_name,
                                               sorted_msa_tib,
                                               ref_y = 0)
    {
    ggplot (data = sorted_msa_tib) +
            aes(x = rsp_euc_realized_Ftot_and_cost_in_err_frac,
                                        y = rs_solution_cost_err_frac, #rsr_COR_euc_out_err_frac,
            #                            color = rsp_combined_err_label)) +
                                        color = id) +
#            geom_point() +
        geom_point(shape=".") +
        
            scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +
            stat_smooth(method = "lm", col = "green") +
    
        # ggplot (data = sorted_msa_tib) +
        #       geom_point (mapping = ) +
        #     #scale_color_viridis(discrete=TRUE) +
        #     scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +
        #
            ggtitle (paste0 (rs_name, " - Total input error vs. Signed cost err frac"    #Total output error"
                             )) +
            theme(plot.title = element_text(hjust = 0.5)) +    #  To center the title
    
              geom_hline (yintercept = ref_y, linetype="dashed",
                            color = "black", size=0.5) +
              geom_abline (intercept=0, slope=1  #, linetype, color, size
                           ) +
              geom_abline (intercept=0, slope=5  #, linetype, color, size
                           ) +
              geom_abline (intercept=0, slope=10  #, linetype, color, size
                           )
    }

#===============================================================================

gg_eucInTot_vs_signedCostErrFrac_facetted_by_err_label <- function (rs_name,
                                                            sorted_msa_tib,
                                                            ref_y = 0)
    {
    ggplot (data = sorted_msa_tib) +
      geom_point (mapping = aes(x = rsp_euc_realized_Ftot_and_cost_in_err_frac,
                                y = rs_solution_cost_err_frac,
    #                            color = rsp_combined_err_label)) +
    #                             color = id
    # ,
    # shape="."
    # )) +
# color = id
#     ), 
#     shape="."
#     ) +
 color = id
    ), 
    shape="."
    ) +

    #scale_color_viridis(discrete=TRUE) +
    #scale_color_brewer(palette="Set1") +
    scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +

    ggtitle (paste0 (rs_name, " - Total input error vs. Signed cost err frac by Error Class")) +
    theme(plot.title = element_text(hjust = 0.5)) +    #  To center the title

      facet_wrap (~ rsp_combined_err_label, nrow = 5) +
      geom_hline (yintercept = ref_y, linetype="dashed",
                    color = "black", size=0.5) +
      geom_abline (intercept=0, slope=1  #, linetype, color, size
                   ) +
      geom_abline (intercept=0, slope=5  #, linetype, color, size
                   ) +
      geom_abline (intercept=0, slope=10  #, linetype, color, size
                   )
    }


#===============================================================================

gg_eucInTot_vs_sppRepShortfall_all_on_1 <- function (rs_name,
                                               sorted_msa_tib,
                                               ref_y = 0)
    {
    ggplot (data = sorted_msa_tib) +
            aes(x = rsp_euc_realized_Ftot_and_cost_in_err_frac,
                                        y = rsr_COR_spp_rep_shortfall, #rsr_COR_euc_out_err_frac,
            #                            color = rsp_combined_err_label)) +
#                                         color = id
#         ,
#         shape="."
#         ) +
# ##            geom_point() +
# #        geom_point(shape=".") +

                                    color = id) +
        geom_point(shape=".", alpha=1) +

    
            scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +
            stat_smooth(method = "lm", col = "green") +
    
        # ggplot (data = sorted_msa_tib) +
        #       geom_point (mapping = ) +
        #     #scale_color_viridis(discrete=TRUE) +
        #     scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +
        #
            ggtitle (paste0 (rs_name, " - Total input error vs. Spp Rep Shortfall"    #Total output error"
                             )) +
            theme(plot.title = element_text(hjust = 0.5)) +    #  To center the title
    
              geom_hline (yintercept = ref_y, linetype="dashed",
                            color = "black", size=0.5) +
              geom_abline (intercept=0, slope=1  #, linetype, color, size
                           ) +
              geom_abline (intercept=0, slope=5  #, linetype, color, size
                           ) +
              geom_abline (intercept=0, slope=10  #, linetype, color, size
                           )
    }

#===============================================================================

gg_eucInTot_vs_sppRepShortfall_facetted_by_err_label <- function (rs_name,
                                                            sorted_msa_tib,
                                                            ref_y = 0)
    {
    ggplot (data = sorted_msa_tib) +
      geom_point (mapping = aes(x = rsp_euc_realized_Ftot_and_cost_in_err_frac,
                                y = rsr_COR_spp_rep_shortfall,
    #                            color = rsp_combined_err_label)) +
    #                             color = id
    # , 
    # shape="."
    # )) +
# color = id
#     ), 
#     shape="."
#     ) +
 color = id
    ), 
    shape="."
    ) +

    #scale_color_viridis(discrete=TRUE) +
    #scale_color_brewer(palette="Set1") +
    scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +

    ggtitle (paste0 (rs_name, " - Total input error vs. Spp Rep Shortfall by Error Class")) +
    theme(plot.title = element_text(hjust = 0.5)) +    #  To center the title

      facet_wrap (~ rsp_combined_err_label, nrow = 5) +
      geom_hline (yintercept = ref_y, linetype="dashed",
                    color = "black", size=0.5) +
      geom_abline (intercept=0, slope=1  #, linetype, color, size
                   ) +
      geom_abline (intercept=0, slope=5  #, linetype, color, size
                   ) +
      geom_abline (intercept=0, slope=10  #, linetype, color, size
                   )
    }
```

```{r ggplotSignedErrFracsAndRepShortfalls}

#-----  Marxan_SA

#--  rs_solution_cost_err_frac

gg_eucInTot_vs_signedCostErrFrac_all_on_1 ("Marxan_SA", easyHard_df_Marxan_SA, ref_y = 0)
gg_eucInTot_vs_signedCostErrFrac_facetted_by_err_label ("Marxan_SA", easyHard_df_Marxan_SA, ref_y = 0)
# easyHard_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df
gg_eucInTot_vs_signedCostErrFrac_all_on_1 ("Marxan_SA", easyHard_Marxan_SA_not_huge_out_err_df, ref_y = 0)
gg_eucInTot_vs_signedCostErrFrac_facetted_by_err_label ("Marxan_SA", easyHard_Marxan_SA_not_huge_out_err_df, ref_y = 0)

gg_eucInTot_vs_signedCostErrFrac_all_on_1 ("Marxan_SA", working_df_Marxan_SA, ref_y = 0)
gg_eucInTot_vs_signedCostErrFrac_facetted_by_err_label ("Marxan_SA", working_df_Marxan_SA, ref_y = 0)
# working_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df
gg_eucInTot_vs_signedCostErrFrac_all_on_1 ("Marxan_SA", working_Marxan_SA_not_huge_out_err_df, ref_y = 0)
gg_eucInTot_vs_signedCostErrFrac_facetted_by_err_label ("Marxan_SA", working_Marxan_SA_not_huge_out_err_df, ref_y = 0)

#--  rsr_COR_spp_rep_shortfall 

gg_eucInTot_vs_sppRepShortfall_all_on_1 ("Marxan_SA", easyHard_df_Marxan_SA, ref_y = 0)
gg_eucInTot_vs_sppRepShortfall_facetted_by_err_label ("Marxan_SA", easyHard_df_Marxan_SA, ref_y = 0)
# easyHard_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df
gg_eucInTot_vs_sppRepShortfall_all_on_1 ("Marxan_SA", easyHard_Marxan_SA_not_huge_out_err_df, ref_y = 0)
gg_eucInTot_vs_sppRepShortfall_facetted_by_err_label ("Marxan_SA", easyHard_Marxan_SA_not_huge_out_err_df, ref_y = 0)

gg_eucInTot_vs_sppRepShortfall_all_on_1 ("Marxan_SA", working_df_Marxan_SA, ref_y = 0)
gg_eucInTot_vs_sppRepShortfall_facetted_by_err_label ("Marxan_SA", working_df_Marxan_SA, ref_y = 0)
# working_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> working_Marxan_SA_not_huge_out_err_df
gg_eucInTot_vs_sppRepShortfall_all_on_1 ("Marxan_SA", working_Marxan_SA_not_huge_out_err_df, ref_y = 0)
gg_eucInTot_vs_sppRepShortfall_facetted_by_err_label ("Marxan_SA", working_Marxan_SA_not_huge_out_err_df, ref_y = 0)
```

####  Spp rep shortfall vs. Signed cost error

```{r funcsGgplotRepShortfallVsSignedErrFracs, include=FALSE}
#===============================================================================

gg_sppRepShortfall_vs_signedCostErrFrac_all_on_1 <- function (rs_name,
                                               sorted_msa_tib,
                                               ref_y = 0)
    {
    ggplot (data = sorted_msa_tib) +
            aes(x = rsr_COR_spp_rep_shortfall,
                                        y = rs_solution_cost_err_frac, #rsr_COR_euc_out_err_frac,
            #                            color = rsp_combined_err_label)) +
#                                         color = id
#             ,
#             shape="."
#             ) +
# #            geom_point() +
# #        geom_point(shape=".") +


            #                            color = rsp_combined_err_label)) +
#                                         color = id
#         ,
#         shape="."
#         ) +
# ##            geom_point() +
# #        geom_point(shape=".") +

                                    color = id) +
        geom_point(shape=".", alpha=1) +

    

            scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +
            stat_smooth(method = "lm", col = "green") +
    
        # ggplot (data = sorted_msa_tib) +
        #       geom_point (mapping = ) +
        #     #scale_color_viridis(discrete=TRUE) +
        #     scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +
        #
            ggtitle (paste0 (rs_name, " - Spp Rep Shortfall vs. Signed cost err frac"    #Total output error"
                             )) +
            theme(plot.title = element_text(hjust = 0.5)) +    #  To center the title
    
              geom_hline (yintercept = ref_y, linetype="dashed",
                            color = "black", size=0.5) +
              geom_abline (intercept=0, slope=1  #, linetype, color, size
                           ) +
              geom_abline (intercept=0, slope=5  #, linetype, color, size
                           ) +
              geom_abline (intercept=0, slope=10  #, linetype, color, size
                           )
    }

#===============================================================================

gg_sppRepShortfall_vs_signedCostErrFrac_facetted_by_err_label <- function (rs_name,
                                                            sorted_msa_tib,
                                                            ref_y = 0)
    {
    ggplot (data = sorted_msa_tib) +
      geom_point (mapping = aes(x = rsr_COR_spp_rep_shortfall,
                                y = rs_solution_cost_err_frac,
    #                            color = rsp_combined_err_label)) +
    #                             color = id
    # ,
    # shape="."
    # )) +
 # color = id
 #    ), 
 #    shape="."
 #    ) +
 color = id
    ), 
    shape="."
    ) +
        
#        geom_point(shape=".") +
        
    #scale_color_viridis(discrete=TRUE) +
    #scale_color_brewer(palette="Set1") +
    scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +

    ggtitle (paste0 (rs_name, " - Spp Rep Shortfall vs. Signed cost err frac by Error Class")) +
    theme(plot.title = element_text(hjust = 0.5)) +    #  To center the title

      facet_wrap (~ rsp_combined_err_label, nrow = 5) +
      geom_hline (yintercept = ref_y, linetype="dashed",
                    color = "black", size=0.5) +
      geom_abline (intercept=0, slope=1  #, linetype, color, size
                   ) +
      geom_abline (intercept=0, slope=5  #, linetype, color, size
                   ) +
      geom_abline (intercept=0, slope=10  #, linetype, color, size
                   )
    }
```

```{r GgplotRepShortfallVsSignedErrFracs}

#-----  Marxan_SA

#--  rs_solution_cost_err_frac

gg_sppRepShortfall_vs_signedCostErrFrac_all_on_1 ("Marxan_SA", easyHard_df_Marxan_SA, ref_y = 0)
gg_sppRepShortfall_vs_signedCostErrFrac_facetted_by_err_label ("Marxan_SA", easyHard_df_Marxan_SA, ref_y = 0)
# easyHard_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df
gg_sppRepShortfall_vs_signedCostErrFrac_all_on_1 ("Marxan_SA", easyHard_Marxan_SA_not_huge_out_err_df, ref_y = 0)
gg_sppRepShortfall_vs_signedCostErrFrac_facetted_by_err_label ("Marxan_SA", easyHard_Marxan_SA_not_huge_out_err_df, ref_y = 0)

gg_sppRepShortfall_vs_signedCostErrFrac_all_on_1 ("Marxan_SA", working_df_Marxan_SA, ref_y = 0)
gg_sppRepShortfall_vs_signedCostErrFrac_facetted_by_err_label ("Marxan_SA", working_df_Marxan_SA, ref_y = 0)
# working_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df
gg_sppRepShortfall_vs_signedCostErrFrac_all_on_1 ("Marxan_SA", working_Marxan_SA_not_huge_out_err_df, ref_y = 0)
gg_sppRepShortfall_vs_signedCostErrFrac_facetted_by_err_label ("Marxan_SA", working_Marxan_SA_not_huge_out_err_df, ref_y = 0)

#--  rsr_COR_spp_rep_shortfall 

gg_eucInTot_vs_sppRepShortfall_all_on_1 ("Marxan_SA", easyHard_df_Marxan_SA, ref_y = 0)
gg_eucInTot_vs_sppRepShortfall_facetted_by_err_label ("Marxan_SA", easyHard_df_Marxan_SA, ref_y = 0)
# easyHard_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df
gg_eucInTot_vs_sppRepShortfall_all_on_1 ("Marxan_SA", easyHard_Marxan_SA_not_huge_out_err_df, ref_y = 0)
gg_eucInTot_vs_sppRepShortfall_facetted_by_err_label ("Marxan_SA", easyHard_Marxan_SA_not_huge_out_err_df, ref_y = 0)

gg_eucInTot_vs_sppRepShortfall_all_on_1 ("Marxan_SA", working_df_Marxan_SA, ref_y = 0)
gg_eucInTot_vs_sppRepShortfall_facetted_by_err_label ("Marxan_SA", working_df_Marxan_SA, ref_y = 0)
# working_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df
gg_eucInTot_vs_sppRepShortfall_all_on_1 ("Marxan_SA", working_Marxan_SA_not_huge_out_err_df, ref_y = 0)
gg_eucInTot_vs_sppRepShortfall_facetted_by_err_label ("Marxan_SA", working_Marxan_SA_not_huge_out_err_df, ref_y = 0)
```

#### Also look at problem of putting errors on equal footing, i.e., how much error is _possible_

I've also tracked the _fraction of possible_ overcost and undercost as a way of trying to put problems on a more equal footing.  

- Overcost:  

    - The largest possible error is related to what fraction of the landscape is required in the optimal solution.  If the optimal solution takes up most of the landscape, then only a tiny overcost is possible.    
    - max overcost error = (total landscape cost - optimal cost) / optimal cost    
    -                    = (total landscape cost / optimal cost) - 1    
    
- Undercost:  

    - In all cases, the undercost is bounded by 100%, since the error is a fraction of the optimal cost and costs can't go less than 0 and once you hit 0 cost error is 100%.    
    - max undercost error = (optimal cost - min cost possible) / optimal cost    
    -                     = (optimal cost - 0) / optimal cost = 1    


#### Results and their errors  

- rs_over_opt_cost_err_frac_of_possible_overcost 
- rs_under_opt_cost_err_frac_of_possible_undercost 

```{r funcsForGgplotPossibleErrorFracs, include=FALSE}
#===============================================================================

gg_eucInTot_vs_fracPossibleOver_all_on_1 <- function (rs_name,
                                               sorted_msa_tib,
                                               ref_y = 0)
    {
    
# - rs_solution_cost_err_frac 
# - abs_rs_solution_cost_err_frac 
# 
# - rs_over_opt_cost_err_frac_of_possible_overcost 
# - rs_under_opt_cost_err_frac_of_possible_undercost 
# 
# - rsr_COR_spp_rep_shortfall 
# - rsr_COR_solution_FRAC_spp_covered 

    
    
    ggplot (data = sorted_msa_tib) +
            aes(x = rsp_euc_realized_Ftot_and_cost_in_err_frac,
                                        y = rs_over_opt_cost_err_frac_of_possible_overcost, #rsr_COR_euc_out_err_frac,
            #                            color = rsp_combined_err_label)) +
#                                         color = id
#             ,
#             shape="."
#             ) +
# #            geom_point() +
# #        geom_point(shape=".") +


             #                            color = rsp_combined_err_label)) +
#                                         color = id
#         ,
#         shape="."
#         ) +
# ##            geom_point() +
# #        geom_point(shape=".") +

                                    color = id) +
        geom_point(shape=".", alpha=1) +

    

            scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +
            stat_smooth(method = "lm", col = "green") +
    
        # ggplot (data = sorted_msa_tib) +
        #       geom_point (mapping = ) +
        #     #scale_color_viridis(discrete=TRUE) +
        #     scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +
        #
            ggtitle (paste0 (rs_name, " - Total input error vs. Over err frac of possible"    #Total output error"
                             )) +
            theme(plot.title = element_text(hjust = 0.5)) +    #  To center the title
    
              geom_hline (yintercept = ref_y, linetype="dashed",
                            color = "black", size=0.5) +
              geom_abline (intercept=0, slope=1  #, linetype, color, size
                           ) +
              geom_abline (intercept=0, slope=5  #, linetype, color, size
                           ) +
              geom_abline (intercept=0, slope=10  #, linetype, color, size
                           )
    }

#===============================================================================

gg_eucInTot_vs_fracPossibleOver_facetted_by_err_label <- function (rs_name,
                                                            sorted_msa_tib,
                                                            ref_y = 0)
    {
    ggplot (data = sorted_msa_tib) +
      geom_point (mapping = aes(x = rsp_euc_realized_Ftot_and_cost_in_err_frac,
                                y = rs_over_opt_cost_err_frac_of_possible_overcost,
    #                            color = rsp_combined_err_label)) +
    #                             color = id
    # ,
    # shape="."
    # )) +
    # color = id
    # ), 
    # shape="."
    # ) +
 color = id
    ), 
    shape="."
    ) +
        
        
     
#        geom_point(shape=".") +

    #scale_color_viridis(discrete=TRUE) +
    #scale_color_brewer(palette="Set1") +
    scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +

    ggtitle (paste0 (rs_name, " - Total input error vs. Over err frac of possible by Error Class")) +
    theme(plot.title = element_text(hjust = 0.5)) +    #  To center the title

      facet_wrap (~ rsp_combined_err_label, nrow = 5) +
      geom_hline (yintercept = ref_y, linetype="dashed",
                    color = "black", size=0.5) +
      geom_abline (intercept=0, slope=1  #, linetype, color, size
                   ) +
      geom_abline (intercept=0, slope=5  #, linetype, color, size
                   ) +
      geom_abline (intercept=0, slope=10  #, linetype, color, size
                   )
    }

#===============================================================================

gg_eucInTot_vs_fracPossibleUnder_all_on_1 <- function (rs_name,
                                               sorted_msa_tib,
                                               ref_y = 0)
    {
    
# - rs_solution_cost_err_frac 
# - abs_rs_solution_cost_err_frac 
# 
# - rs_over_opt_cost_err_frac_of_possible_overcost 
# - rs_under_opt_cost_err_frac_of_possible_undercost 
# 
# - rsr_COR_spp_rep_shortfall 
# - rsr_COR_solution_FRAC_spp_covered 

    
    
    ggplot (data = sorted_msa_tib) +
            aes(x = rsp_euc_realized_Ftot_and_cost_in_err_frac,
                                        y = rs_under_opt_cost_err_frac_of_possible_undercost, #rsr_COR_euc_out_err_frac,
            #                            color = rsp_combined_err_label)) +
#                                         color = id
#             ,
#             shape="."
#             ) +
# #            geom_point() +
# #        geom_point(shape=".") +


            #                            color = rsp_combined_err_label)) +
#                                         color = id
#         ,
#         shape="."
#         ) +
# ##            geom_point() +
# #        geom_point(shape=".") +

                                    color = id) +
        geom_point(shape=".", alpha=1) +

    

            scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +
            stat_smooth(method = "lm", col = "green") +
    
        # ggplot (data = sorted_msa_tib) +
        #       geom_point (mapping = ) +
        #     #scale_color_viridis(discrete=TRUE) +
        #     scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +
        #
            ggtitle (paste0 (rs_name, " - Total input error vs. Under err frac of possible"    #Total output error"
                             )) +
            theme(plot.title = element_text(hjust = 0.5)) +    #  To center the title
    
              geom_hline (yintercept = ref_y, linetype="dashed",
                            color = "black", size=0.5) +
              geom_abline (intercept=0, slope=1  #, linetype, color, size
                           ) +
              geom_abline (intercept=0, slope=5  #, linetype, color, size
                           ) +
              geom_abline (intercept=0, slope=10  #, linetype, color, size
                           )
    }

#===============================================================================

gg_eucInTot_vs_fracPossibleUnder_facetted_by_err_label <- function (rs_name,
                                                            sorted_msa_tib,
                                                            ref_y = 0)
    {
    ggplot (data = sorted_msa_tib) +
      geom_point (mapping = aes(x = rsp_euc_realized_Ftot_and_cost_in_err_frac,
                                y = rs_under_opt_cost_err_frac_of_possible_undercost,
    #                            color = rsp_combined_err_label)) +
    #                             color = id
    # ,
    # shape="."
    # )) +
 # color = id
 #    ), 
 #    shape="."
 #    ) +
 color = id
    ), 
    shape="."
    ) +
        
        
#        geom_point(shape=".") +

    #scale_color_viridis(discrete=TRUE) +
    #scale_color_brewer(palette="Set1") +
    scale_color_manual(breaks = c("Easy", "Hard"), values=c("blue", "red")) +

    ggtitle (paste0 (rs_name, " - Total input error vs. Under err frac of possible by Error Class")) +
    theme(plot.title = element_text(hjust = 0.5)) +    #  To center the title

      facet_wrap (~ rsp_combined_err_label, nrow = 5) +
      geom_hline (yintercept = ref_y, linetype="dashed",
                    color = "black", size=0.5) +
      geom_abline (intercept=0, slope=1  #, linetype, color, size
                   ) +
      geom_abline (intercept=0, slope=5  #, linetype, color, size
                   ) +
      geom_abline (intercept=0, slope=10  #, linetype, color, size
                   )
    }
```

```{r ggplotPossibleErrorFracs}

#-----  Marxan_SA

#--  OVER cost frac possible

gg_eucInTot_vs_fracPossibleOver_all_on_1 ("Marxan_SA", easyHard_df_Marxan_SA, ref_y = 0)
gg_eucInTot_vs_fracPossibleOver_facetted_by_err_label ("Marxan_SA", easyHard_df_Marxan_SA, ref_y = 0)
# easyHard_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df
gg_eucInTot_vs_fracPossibleOver_all_on_1 ("Marxan_SA", easyHard_Marxan_SA_not_huge_out_err_df, ref_y = 0)
gg_eucInTot_vs_fracPossibleOver_facetted_by_err_label ("Marxan_SA", easyHard_Marxan_SA_not_huge_out_err_df, ref_y = 0)

gg_eucInTot_vs_fracPossibleOver_all_on_1 ("Marxan_SA", working_df_Marxan_SA, ref_y = 0)
gg_eucInTot_vs_fracPossibleOver_facetted_by_err_label ("Marxan_SA", working_df_Marxan_SA, ref_y = 0)
# working_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df
gg_eucInTot_vs_fracPossibleOver_all_on_1 ("Marxan_SA", working_Marxan_SA_not_huge_out_err_df, ref_y = 0)
gg_eucInTot_vs_fracPossibleOver_facetted_by_err_label ("Marxan_SA", working_Marxan_SA_not_huge_out_err_df, ref_y = 0)

#--  UNDER cost frac possible

gg_eucInTot_vs_fracPossibleUnder_all_on_1 ("Marxan_SA", easyHard_df_Marxan_SA, ref_y = 0)
gg_eucInTot_vs_fracPossibleUnder_facetted_by_err_label ("Marxan_SA", easyHard_df_Marxan_SA, ref_y = 0)
# easyHard_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df
gg_eucInTot_vs_fracPossibleUnder_all_on_1 ("Marxan_SA", easyHard_Marxan_SA_not_huge_out_err_df, ref_y = 0)
gg_eucInTot_vs_fracPossibleUnder_facetted_by_err_label ("Marxan_SA", easyHard_Marxan_SA_not_huge_out_err_df, ref_y = 0)

gg_eucInTot_vs_fracPossibleUnder_all_on_1 ("Marxan_SA", working_df_Marxan_SA, ref_y = 0)
gg_eucInTot_vs_fracPossibleUnder_facetted_by_err_label ("Marxan_SA", working_df_Marxan_SA, ref_y = 0)
# working_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df
gg_eucInTot_vs_fracPossibleUnder_all_on_1 ("Marxan_SA", working_Marxan_SA_not_huge_out_err_df, ref_y = 0)
gg_eucInTot_vs_fracPossibleUnder_facetted_by_err_label ("Marxan_SA", working_Marxan_SA_not_huge_out_err_df, ref_y = 0)


```

----------------------------

----------------------------

#  Predicting performance of specific RS on specific problems

Given all this variability, can you predict how a particular reserve selector will perform on a specific problem?

##  Compute correlations among primary working data variables

```{r computeAllCorrs}

library (corrplot)

    #  Compute correlation matrix after stripping out non-continuous 
    #  variables.

continuous_vars_working_df_Marxan_SA = 
    select (working_df_Marxan_SA, #c (
            
                    #  Input descriptors
                    rsp_num_PUs, 
                    rsp_num_spp, 
                    rsp_num_spp_per_PU, 
                    rsp_correct_solution_cost, 
            
                    sppPUsum,
                    sppPUprod, 
            
            #  Post-gen knowable problem descriptors
            
                #  Species and PU counts
                        # rsp_app_num_spp, 
                        # rsp_app_num_PUs, 
                    
                #  igraph package metrics
    #                ig_rsp_UUID, 
            
                        # ig_top, 
                        # ig_bottom, 
                        # ig_num_edges_m, 
                        # ig_ktop, 
                        # ig_kbottom, 
                        # ig_bidens, 
                        # ig_lcctop, 
                        # ig_lccbottom, 
                        # ig_distop, 
                        # ig_disbottom, 
                        # ig_cctop, 
                        # ig_ccbottom, 
                        # ig_cclowdottop, 
                        # ig_cclowdotbottom, 
                        # ig_cctopdottop, 
                        # ig_cctopdotbottom, 
                    ig_mean_bottom_bg_redundancy, 
                    ig_median_bottom_bg_redundancy, 
                    ig_mean_top_bg_redundancy, 
                    ig_median_top_bg_redundancy, 
                    
                    # ig_user_time, 
                    # ig_system_time, 
                    # ig_elapsed_time, 
                    # ig_user_child_time, 
                    # ig_sys_child_time, 
                                    
                #  bipartite package metrics
    #                bip_rsp_UUID, 
            
                    connectance, 
                            # number.of.PUs, 
                            # number.of.Spp, 
                    
                    # bip_user_time, 
                    # bip_system_time, 
                    # bip_elapsed_time, 
                    # bip_user_child_time, 
                    # bip_sys_child_time, 
    
    
                #  Possibly knowable realized input error values
                            # rsp_realized_median_abs_cost_err_frac, 
                            # rsp_realized_mean_abs_cost_err_frac, 
                            # rsp_realized_sd_abs_cost_err_frac, 
                            # rsp_FP_const_rate, 
                            # rsp_FN_const_rate, 
                    
                    rsp_realized_FP_rate, 
                    rsp_realized_FN_rate, 
                    rsp_realized_Ftot_rate, 
                    rsp_euc_realized_FP_and_cost_in_err_frac, 
                    rsp_euc_realized_FN_and_cost_in_err_frac, 
                    rsp_euc_realized_Ftot_and_cost_in_err_frac, 
                    
#                        rsp_wrap_is_imperfect,
                            
    
                #  Results and their errors
                            # rs_solution_cost, 
                            # rs_solution_cost_err_frac, 
                            # abs_rs_solution_cost_err_frac, 
                            # 
                            # rs_over_opt_cost_err_frac_of_possible_overcost, 
                            # rs_under_opt_cost_err_frac_of_possible_undercost, 
                            # 
                    rsr_COR_euc_out_err_frac,
                            # 
                            # rsr_COR_spp_rep_shortfall, 
                            # rsr_COR_solution_NUM_spp_covered, 
                            # rsr_COR_solution_FRAC_spp_covered, 
    
                    err_mag
    )
#)

correlations = cor (continuous_vars_working_df_Marxan_SA)

    #  Plot the correlation matrix.

corrplot (correlations, tl.cex=0.5
#          , order = "hclust"    #  This fails because of NAs or NaNs in the data...
          )

dim (correlations)
correlations [, 18:19]
```

## NOT cheating:  Fit prediction using problem size 

```{r}
cat ("\n...  NOT cheating:  Fit prediction using problem size  ...\n")

            # #  Input descriptors
            #         rsp_num_PUs, 
            #         rsp_num_spp, 
            #         rsp_num_spp_per_PU, 
            #         rsp_correct_solution_cost, 
            # 
            #         sppPUsum,
            #         sppPUprod, 

easyHard_Marxan_SA_lm_fit = lm (rsr_COR_euc_out_err_frac ~ 
                          rsp_num_PUs + rsp_num_spp + 
                          rsp_num_spp_per_PU + sppPUprod, 
                      easyHard_df_Marxan_SA)

summary (easyHard_Marxan_SA_lm_fit)
plot (easyHard_Marxan_SA_lm_fit)
```

```{r}
# easyHard_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df

easyHard_Marxan_SA_not_huge_out_err_lm_fit = 
    lm (rsr_COR_euc_out_err_frac ~ rsp_num_PUs + rsp_num_spp + 
                                   rsp_num_spp_per_PU + sppPUprod, 
        easyHard_Marxan_SA_not_huge_out_err_df)

summary (easyHard_Marxan_SA_not_huge_out_err_lm_fit)
plot (easyHard_Marxan_SA_not_huge_out_err_lm_fit)
```

```{r}
working_Marxan_SA_lm_fit = lm (rsr_COR_euc_out_err_frac ~ 
                          rsp_num_PUs + rsp_num_spp + 
                          rsp_num_spp_per_PU + sppPUprod, 
                      working_df_Marxan_SA)

summary (working_Marxan_SA_lm_fit)
plot (working_Marxan_SA_lm_fit)
```

```{r}
# working_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df

working_Marxan_SA_not_huge_out_err_lm_fit = 
    lm (rsr_COR_euc_out_err_frac ~ rsp_num_PUs + rsp_num_spp + 
                                   rsp_num_spp_per_PU + sppPUprod, 
        working_Marxan_SA_not_huge_out_err_df)

summary (working_Marxan_SA_not_huge_out_err_lm_fit)
plot (working_Marxan_SA_not_huge_out_err_lm_fit)
```

##  Graph measures help

###  Without cheating

- Graph measures do broadly predict trend in output error, but still lots of variability. 
- What about with problem size information too?

```{r}
cat ("\n...  NOT cheating:  Fit prediction using graph measures, problem size  ...\n")

                #  igraph package metrics
            #                ig_rsp_UUID, 
            
                    # ig_top, 
                    # ig_bottom, 
                    # ig_num_edges_m, 
                    # ig_ktop, 
                    # ig_kbottom, 
                    # ig_bidens, 
                    # ig_lcctop, 
                    # ig_lccbottom, 
                    # ig_distop, 
                    # ig_disbottom, 
                    # ig_cctop, 
                    # ig_ccbottom, 
                    # ig_cclowdottop, 
                    # ig_cclowdotbottom, 
                    # ig_cctopdottop, 
                    # ig_cctopdotbottom, 
                    # ig_mean_bottom_bg_redundancy, 
                    # ig_median_bottom_bg_redundancy, 
                    # ig_mean_top_bg_redundancy, 
                    # ig_median_top_bg_redundancy, 
                    
                            # ig_user_time, 
                            # ig_system_time, 
                            # ig_elapsed_time, 
                            # ig_user_child_time, 
                            # ig_sys_child_time, 
                                    
                #  bipartite package metrics
            #                bip_rsp_UUID, 
            
                    # connectance, 
```

###  Quick and dirty plot of redundancy vs. output error fraction

Still lots of variance at every level, however, redundancy does seem to put a lower bound on the amount of input error in this data, i.e., you can bet that your output error will be **at least** this much.  That seems pretty useful even if you can't predict the exact error amount.  

```{r}
plot (easyHard_df_Marxan_SA$ig_median_bottom_bg_redundancy, easyHard_df_Marxan_SA$rsr_COR_euc_out_err_frac)
plot (easyHard_df_Marxan_SA$ig_median_top_bg_redundancy, easyHard_df_Marxan_SA$rsr_COR_euc_out_err_frac)

plot (working_df_Marxan_SA$ig_median_bottom_bg_redundancy, working_df_Marxan_SA$rsr_COR_euc_out_err_frac)
plot (working_df_Marxan_SA$ig_median_top_bg_redundancy, working_df_Marxan_SA$rsr_COR_euc_out_err_frac)
```

```{r}
                    # ig_mean_bottom_bg_redundancy, 
                    # ig_median_bottom_bg_redundancy, 
                    # ig_mean_top_bg_redundancy, 
                    # ig_median_top_bg_redundancy, 
                    
                            # ig_user_time, 
                            # ig_system_time, 
                            # ig_elapsed_time, 
                            # ig_user_child_time, 
                            # ig_sys_child_time, 
                                    
                #  bipartite package metrics
            #                bip_rsp_UUID, 
            
                    # connectance, 


easyHard_Marxan_SA_lm_fit = lm (rsr_COR_euc_out_err_frac ~ 
                          ig_median_bottom_bg_redundancy + ig_median_top_bg_redundancy + 
                          connectance, 
                      easyHard_df_Marxan_SA)

summary (easyHard_Marxan_SA_lm_fit)
plot (easyHard_Marxan_SA_lm_fit)
```

```{r}
# easyHard_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df

easyHard_Marxan_SA_not_huge_out_err_lm_fit = 
    lm (rsr_COR_euc_out_err_frac ~ 
                          ig_median_bottom_bg_redundancy + ig_median_top_bg_redundancy + 
                          connectance, 
        easyHard_Marxan_SA_not_huge_out_err_df)

summary (easyHard_Marxan_SA_not_huge_out_err_lm_fit)
plot (easyHard_Marxan_SA_not_huge_out_err_lm_fit)
```

```{r}
working_Marxan_SA_lm_fit = lm (rsr_COR_euc_out_err_frac ~ 
                          ig_median_bottom_bg_redundancy + ig_median_top_bg_redundancy + 
                          connectance, 
                      working_df_Marxan_SA)

summary (working_Marxan_SA_lm_fit)
plot (working_Marxan_SA_lm_fit)
```

```{r}
# working_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df

working_Marxan_SA_not_huge_out_err_lm_fit = 
    lm (rsr_COR_euc_out_err_frac ~ 
                          ig_median_bottom_bg_redundancy + ig_median_top_bg_redundancy + 
                          connectance, 
        working_Marxan_SA_not_huge_out_err_df)

summary (working_Marxan_SA_not_huge_out_err_lm_fit)
plot (working_Marxan_SA_not_huge_out_err_lm_fit)
```

####  Again, without cheating, graph measures + problem size data

```{r}
                    # ig_mean_bottom_bg_redundancy, 
                    # ig_median_bottom_bg_redundancy, 
                    # ig_mean_top_bg_redundancy, 
                    # ig_median_top_bg_redundancy, 
                    
                            # ig_user_time, 
                            # ig_system_time, 
                            # ig_elapsed_time, 
                            # ig_user_child_time, 
                            # ig_sys_child_time, 
                                    
                #  bipartite package metrics
            #                bip_rsp_UUID, 
            
                    # connectance, 
easyHard_Marxan_SA_lm_fit = lm (rsr_COR_euc_out_err_frac ~ 
                          ig_median_bottom_bg_redundancy + ig_median_top_bg_redundancy + 
                          connectance + 
                              rsp_num_PUs + rsp_num_spp + 
                                   rsp_num_spp_per_PU + sppPUprod, 
                      easyHard_df_Marxan_SA)

summary (easyHard_Marxan_SA_lm_fit)
plot (easyHard_Marxan_SA_lm_fit)
```

```{r}
# easyHard_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df

easyHard_Marxan_SA_not_huge_out_err_lm_fit = 
    lm (rsr_COR_euc_out_err_frac ~ 
                          ig_median_bottom_bg_redundancy + ig_median_top_bg_redundancy + 
                          connectance + 
                              rsp_num_PUs + rsp_num_spp + 
                                   rsp_num_spp_per_PU + sppPUprod, 
        easyHard_Marxan_SA_not_huge_out_err_df)

summary (easyHard_Marxan_SA_not_huge_out_err_lm_fit)
plot (easyHard_Marxan_SA_not_huge_out_err_lm_fit)
```

```{r}
working_Marxan_SA_lm_fit = lm (rsr_COR_euc_out_err_frac ~ 
                          ig_median_bottom_bg_redundancy + ig_median_top_bg_redundancy + 
                          connectance + 
                              rsp_num_PUs + rsp_num_spp + 
                                   rsp_num_spp_per_PU + sppPUprod, 
                      working_df_Marxan_SA)

summary (working_Marxan_SA_lm_fit)
plot (working_Marxan_SA_lm_fit)
```

```{r}
# working_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df

working_Marxan_SA_not_huge_out_err_lm_fit__using_graph_and_prob_size = 
    lm (rsr_COR_euc_out_err_frac ~ 
                          ig_median_bottom_bg_redundancy + ig_median_top_bg_redundancy + 
                          connectance + 
                              rsp_num_PUs + rsp_num_spp + 
                                   rsp_num_spp_per_PU + sppPUprod, 
        working_Marxan_SA_not_huge_out_err_df)

summary (working_Marxan_SA_not_huge_out_err_lm_fit__using_graph_and_prob_size)
plot (working_Marxan_SA_not_huge_out_err_lm_fit__using_graph_and_prob_size)
```


###  With cheating

- Generally, output error does increase with input error, but still has large variability.
- Did combination of the two predict better? 

####  Cheating, using input errors only

```{r}
cat ("\n...  CHEATING:  Fit prediction using input error  ...\n")
```

```{r}
easyHard_Marxan_SA_lm_fit = 
    lm (rsr_COR_euc_out_err_frac ~ rsp_euc_realized_Ftot_and_cost_in_err_frac + 
                                   rsp_realized_FP_rate + 
                                   rsp_realized_FN_rate + 
                                   rsp_realized_Ftot_rate + 
                                   rsp_euc_realized_FP_and_cost_in_err_frac + 
                                   rsp_euc_realized_FN_and_cost_in_err_frac, 
                      easyHard_df_Marxan_SA)

summary (easyHard_Marxan_SA_lm_fit)
plot (easyHard_Marxan_SA_lm_fit)
```

```{r}
# easyHard_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df

easyHard_Marxan_SA_not_huge_out_err_lm_fit = 
    lm (rsr_COR_euc_out_err_frac ~ rsp_euc_realized_Ftot_and_cost_in_err_frac + 
                                   rsp_realized_FP_rate + 
                                   rsp_realized_FN_rate + 
                                   rsp_realized_Ftot_rate + 
                                   rsp_euc_realized_FP_and_cost_in_err_frac + 
                                   rsp_euc_realized_FN_and_cost_in_err_frac, 
        easyHard_Marxan_SA_not_huge_out_err_df)

summary (easyHard_Marxan_SA_not_huge_out_err_lm_fit)
plot (easyHard_Marxan_SA_not_huge_out_err_lm_fit)
```

```{r}
working_Marxan_SA_lm_fit = lm (rsr_COR_euc_out_err_frac ~ rsp_euc_realized_Ftot_and_cost_in_err_frac + 
                                   rsp_realized_FP_rate + 
                                   rsp_realized_FN_rate + 
                                   rsp_realized_Ftot_rate + 
                                   rsp_euc_realized_FP_and_cost_in_err_frac + 
                                   rsp_euc_realized_FN_and_cost_in_err_frac, 
                      working_df_Marxan_SA)

summary (working_Marxan_SA_lm_fit)
plot (working_Marxan_SA_lm_fit)
```

```{r}
# working_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df

working_Marxan_SA_not_huge_out_err_lm_fit = 
    lm (rsr_COR_euc_out_err_frac ~ rsp_euc_realized_Ftot_and_cost_in_err_frac + 
                                   rsp_realized_FP_rate + 
                                   rsp_realized_FN_rate + 
                                   rsp_realized_Ftot_rate + 
                                   rsp_euc_realized_FP_and_cost_in_err_frac + 
                                   rsp_euc_realized_FN_and_cost_in_err_frac, 
        working_Marxan_SA_not_huge_out_err_df)

summary (working_Marxan_SA_not_huge_out_err_lm_fit)
plot (working_Marxan_SA_not_huge_out_err_lm_fit)
```



####  Cheating, using input errors and non-cheating problem characteristics

```{r}
cat ("\n...  CHEATING:  Fit prediction using input error, graph measures, problem size  ...\n")
```

```{r}
easyHard_Marxan_SA_lm_fit = lm (rsr_COR_euc_out_err_frac ~ rsp_euc_realized_Ftot_and_cost_in_err_frac + 
                                   rsp_realized_FP_rate + 
                                   rsp_realized_FN_rate + 
                                   rsp_realized_Ftot_rate + 
                                   rsp_euc_realized_FP_and_cost_in_err_frac + 
                                   rsp_euc_realized_FN_and_cost_in_err_frac + 
                          ig_median_bottom_bg_redundancy + ig_median_top_bg_redundancy + 
                          connectance + 
                              rsp_num_PUs + rsp_num_spp + 
                                   rsp_num_spp_per_PU + sppPUprod, 
                      easyHard_df_Marxan_SA)

summary (easyHard_Marxan_SA_lm_fit)
plot (easyHard_Marxan_SA_lm_fit)
```

```{r}
# easyHard_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df

easyHard_Marxan_SA_not_huge_out_err_lm_fit = 
    lm (rsr_COR_euc_out_err_frac ~ rsp_euc_realized_Ftot_and_cost_in_err_frac + 
                                   rsp_realized_FP_rate + 
                                   rsp_realized_FN_rate + 
                                   rsp_realized_Ftot_rate + 
                                   rsp_euc_realized_FP_and_cost_in_err_frac + 
                                   rsp_euc_realized_FN_and_cost_in_err_frac + 
                          ig_median_bottom_bg_redundancy + ig_median_top_bg_redundancy + 
                          connectance + 
                              rsp_num_PUs + rsp_num_spp + 
                                   rsp_num_spp_per_PU + sppPUprod, 
        easyHard_Marxan_SA_not_huge_out_err_df)

summary (easyHard_Marxan_SA_not_huge_out_err_lm_fit)
plot (easyHard_Marxan_SA_not_huge_out_err_lm_fit)
```

```{r}
working_Marxan_SA_lm_fit = lm (rsr_COR_euc_out_err_frac ~ rsp_euc_realized_Ftot_and_cost_in_err_frac + 
                                   rsp_realized_FP_rate + 
                                   rsp_realized_FN_rate + 
                                   rsp_realized_Ftot_rate + 
                                   rsp_euc_realized_FP_and_cost_in_err_frac + 
                                   rsp_euc_realized_FN_and_cost_in_err_frac + 
                          ig_median_bottom_bg_redundancy + ig_median_top_bg_redundancy + 
                          connectance + 
                              rsp_num_PUs + rsp_num_spp + 
                                   rsp_num_spp_per_PU + sppPUprod, 
                      working_df_Marxan_SA)

summary (working_Marxan_SA_lm_fit)
plot (working_Marxan_SA_lm_fit)
```

```{r}
# working_df_Marxan_SA %>% 
#     filter (rsr_COR_euc_out_err_frac <= 1) -> not_huge_out_err_df

working_Marxan_SA_not_huge_out_err_lm_fit = 
    lm (rsr_COR_euc_out_err_frac ~ rsp_euc_realized_Ftot_and_cost_in_err_frac + 
                                   rsp_realized_FP_rate + 
                                   rsp_realized_FN_rate + 
                                   rsp_realized_Ftot_rate + 
                                   rsp_euc_realized_FP_and_cost_in_err_frac + 
                                   rsp_euc_realized_FN_and_cost_in_err_frac + 
                          ig_median_bottom_bg_redundancy + ig_median_top_bg_redundancy + 
                          connectance + 
                              rsp_num_PUs + rsp_num_spp + 
                                   rsp_num_spp_per_PU + sppPUprod, 
        working_Marxan_SA_not_huge_out_err_df)

summary (working_Marxan_SA_not_huge_out_err_lm_fit)
plot (working_Marxan_SA_not_huge_out_err_lm_fit)
```

## Look at residuals using `olsrr` package

Copied from https://cran.r-project.org/web/packages/olsrr/vignettes/residual_diagnostics.html

Residual Diagnostics
Introduction

olsrr offers tools for detecting violation of standard regression assumptions. Here we take a look at residual diagnostics. The standard regression assumptions include the following about residuals/errors:

    The error has a normal distribution (normality assumption).
    The errors have mean zero.
    The errors have same but unknown variance (homoscedasticity assumption).
    The error are independent of each other (independent errors assumption).

```{r}
library (olsrr)

#model = working_Marxan_SA_not_huge_out_err_lm_fit
model = working_Marxan_SA_not_huge_out_err_lm_fit__using_graph_and_prob_size

```

### Residual QQ Plot

Graph for detecting violation of normality assumption.

```{r}
ols_plot_resid_qq (model)
```

### Residual Normality Test

Test for detecting violation of normality assumption.

```{r}
ols_test_normality (model)
```

### Correlation between observed residuals and expected residuals under normality.

```{r}
ols_test_correlation (model)
```

### Residual vs Fitted Values Plot

It is a scatter plot of residuals on the y axis and fitted values on the x axis to detect non-linearity, unequal error variances, and outliers.

Characteristics of a well behaved residual vs fitted plot:

    The residuals spread randomly around the 0 line indicating that the relationship is linear.
    The residuals form an approximate horizontal band around the 0 line indicating homogeneity of error variance.
    No one residual is visibly away from the random pattern of the residuals indicating that there are no outliers.

```{r}
ols_plot_resid_fit (model)
```

### Residual Histogram

Histogram of residuals for detecting violation of normality assumption.

```{r}
ols_plot_resid_hist (model)
```





##  Look at residuals using `car` package

Copied from https://www.statmethods.net/stats/rdiagnostics.html

Regression Diagnostics

An excellent review of regression diagnostics is provided in John Fox's aptly named Overview of Regression Diagnostics (http://socserv.socsci.mcmaster.ca/jfox/Courses/Brazil-2009/index.html). Dr. Fox's `car` package provides advanced utilities for regression modeling. 

```{r}
library (car)
#fit = working_Marxan_SA_not_huge_out_err_lm_fit
fit = working_Marxan_SA_not_huge_out_err_lm_fit__using_graph_and_prob_size
```

###  Outliers

```{r}
    # Assessing Outliers
outlierTest (fit) # Bonferonni p-value for most extreme obs
qqPlot (fit, main="QQ Plot") #qq plot for studentized resid

leveragePlots (fit) # leverage plots
#  THIS FAILS:
#leveragePlots (fit) # leverage plots 
#  ERROR OUTPUT:
#Error in L %*% V : non-conformable arguments
#4.solve(L %*% V %*% t(L))
#3.leveragePlot.lm(model, term, main = "", ...)
#2.leveragePlot(model, term, main = "", ...)
#1.leveragePlots(fit)

```


###  Influential Observations

```{r}
    # added variable plots
#av.Plots (fit)
avPlots (fit)

#    THIS SECTION IS RELATED TO THE mtcars DATASET, NOT MY DATA.
#    NEED TO FIGURE OUT IF/HOW IT TRANSLATES TO MY DATA.
#
#     # Cook's D plot
#     # identify D values > 4/(n-k-1)

# cutoff <- 4 / ((nrow (mtcars)                                - length (fit$coefficients) - 2))
  cutoff <- 4 / ((nrow (working_Marxan_SA_not_huge_out_err_df) - length (fit$coefficients) - 2))
  
plot(fit, which=4, cook.levels=cutoff)
```

That plot marks rows 2094, 3032, and 3033.  Other plots also mention 2092.

```{r}
#glimpse (working_Marxan_SA_not_huge_out_err_df [c(2092, 2094, 3032, 3033), ])

print (working_Marxan_SA_not_huge_out_err_df [c(2092, 2094, 3032, 3033), ])
```

This influencePlot call gives the same error message 7 times.  I think that the format of the call may be out of date.  The message it gives is:

```
"id.method" is not a graphical parameter
```

Looking at the help page for `influencePlot` shows a different way to invoke the "identify" option:

```
id	
settings for labelling points; see link{showLabels} for details. To omit point labelling, set id=FALSE; the default, id=TRUE is equivalent to id=list(method="noteworthy", n=2, cex=1, col=carPalette()[1], location="lr"). The default method="noteworthy" is used only in this function and indicates setting labels for points with large Studentized residuals, hat-values or Cook's distances. Set id=list(method="identify") for interactive point identification.
...
Examples

...
## Not run: 
influencePlot(lm(prestige ~ income + education, data=Duncan), 
    id=list(method="identify"))

## End(Not run)
```

So, modifying the influencePlot() call to match that gives:

```{r}
    # Influence Plot
influencePlot (fit, 
               
                       #id.method="identify", 
                       id=list (method="identify"), 
               
               main="Influence Plot", sub="Circle size is proportial to Cook's Distance" )
```


###  Non-normality

```{r}
    # Normality of Residuals
    # qq plot for studentized resid
qqPlot (fit, main="QQ Plot")

    # distribution of studentized residuals
library (MASS)
sresid <- studres(fit)
hist (sresid, freq=FALSE, main="Distribution of Studentized Residuals")
xfit <- seq (min (sresid), max (sresid), length=40)
yfit <- dnorm (xfit)
lines (xfit, yfit) 
```

### Non-constant Error Variance

```{r}
    # Evaluate homoscedasticity
    # non-constant error variance test
ncvTest (fit)

    # plot studentized residuals vs. fitted values
spreadLevelPlot (fit)
```


###  Multi-collinearity

```{r}
    # Evaluate Collinearity
vif (fit)               # variance inflation factors
sqrt (vif (fit)) > 2    # problem?
```

###  Nonlinearity

```{r}
    # Evaluate Nonlinearity
    # component + residual plot
crPlots (fit)

    # Ceres plots
ceresPlots (fit)
```


###  Non-independence of Errors

```{r}
    # Test for Autocorrelated Errors
durbinWatsonTest(fit)
```


###  Additional Diagnostic Help

The gvlma( ) function in the gvlma package, performs a global validation of linear model assumptions as well separate evaluations of skewness, kurtosis, and heteroscedasticity.

```{r}
    # Global test of model assumptions
library (gvlma)

gvmodel <- gvlma (fit)
summary (gvmodel) 
```






### Plot the last fit, first with a confidence interval and then with a prediction interval.

This code is derived from: https://stackoverflow.com/questions/44865508/using-ggplot2-to-plot-an-already-existing-linear-model

For plotting,   

- the x-axis should be an input error, e.g., to start with, the total input error.
- the y-axis should be an output error, e.g., to start with, the total output error.

```{r}
# # add 'fit', 'lwr', and 'upr' columns to dataframe (generated by predict)
# cars.predict <- cbind(cars, predict(cars.model, interval = 'confidence'))
```

#  Does Easy vs. Hard matter?

Since all existing papers use easy problems (small toy problems or random problems), does that matter?

####  Are descriptive results different?

```{r}
cat ("\n...  Break down by Easy vs. Hard  ...\n")
```

####  Are predictive results different?

Can use the Easy/Hard labels with the same facetting code I had earlier for Base vs Wrap plots.  

- If I train on Easy, how well do I do predicting on Hard?  
- If I train on Hard, how well do I do predicting on Easy?  
- If I train on mixed, how well do I do predicting on mixed?  

```{r}
cat ("\n...  Predict using different train/test sources  ...\n")
```


