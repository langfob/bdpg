---
title: "BDPG data analysis preprocessing"
author: "Bill Langford"
date: "05/08/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#  Set file paths

```{r setFilePaths}
#===============================================================================

# # # base_path = "/Users/bill/D/Projects/ProblemDifficulty/Results/bdpg_20_variants_all_rs_easy_base/bdpg_20_variants_all_rs_easy_base_Combined_err_amts/"
# 
#     #  Easy
# #base_path = "/Users/bill/D/Projects/ProblemDifficulty/Results/bdpg_20_variants_all_rs_easy_base_2nd_attempt/bdpg_20_variants_all_rs_easy_base_2nd_try_Combined_err_amts/"
# 
#     #  Hard
# base_path = "/Users/bill/D/Projects/ProblemDifficulty/Results/bdpg_20_variants_all_rs_HARD_base_first_attempt/bdpg_20_variants_all_rs_HARD_base_1st_try_Combined_err_amts/"

    #  Hard - 2, 5, 7.5, 10 % error
base_path = "/Users/bill/D/Projects/ProblemDifficulty/Results/bdpg_20_variants_all_rs_HARD_base_first_attempt/bdpg_20_variants_all_rs_HARD_base_02_05_075_10_Combined_err_amts/"

suffix = ".combined_results.csv"
```

#  Define functions

```{r funcdefs}
#===============================================================================

load_input_data <- function (rs_name, base_path, suffix)
    {
    infile = paste0 (base_path, rs_name, suffix)

        #  I can't remember why I called these "msa".  It might stand for 
        #  multi-set analysis...
    
    msa_dt         = read.csv (infile, header=TRUE, stringsAsFactors = FALSE)
    
    return (msa_dt)
    }

convert_input_dt_to_sorted_tibble <- function (msa_dt)
    {
    msa_tib        = as.tibble (msa_dt)
    sorted_msa_tib = arrange (msa_tib, rsp_combined_err_label)

    unique_out_errs = unique (sorted_msa_tib$rsr_COR_euc_out_err_frac)
    length (unique_out_errs)
    sorted_unique_out_errs = sort (unique_out_errs)

    cat ("\n\nhead (sorted_unique_OUT_errs) = \n")
    print (head (sorted_unique_out_errs))

    cat ("\ntail (sorted_unique_OUT_errs) = \n")
    print (tail (sorted_unique_out_errs))
    cat ("\n-----------------------")


    unique_in_errs = unique (sorted_msa_tib$rsp_euc_realized_Ftot_and_cost_in_err_frac)
    length (unique_in_errs)
    sorted_unique_in_errs = sort (unique_in_errs)

    cat ("\n\nhead (sorted_unique_IN_errs) = \n")
    print (head (sorted_unique_in_errs))

    cat ("\ntail (sorted_unique_IN_errs) = \n")
    print (tail (sorted_unique_in_errs))
    cat ("\n-----------------------")

    return (sorted_msa_tib)
}

#===============================================================================

```

#  Load input data

```{r loadAndSummarizeInputData}

rs_name = "Gurobi"
msa_dt = load_input_data (rs_name, base_path, suffix)
```

#  Summarize the data

##  Summarize the input data table with base R `summary` function.

Torgo ed. 1, p. 43     

Will probably want to remove this at some point because there are so many columns in the table that the output is huge.

```{r summarizeInputData}
summary (msa_dt)
```

### Summarize with Hmisc's `describe` function.

Torgo ed. 1, p. 44, footnote 6.

```{r describeInputData}
library (Hmisc)
describe (msa_dt)
```

##  Show histogram of any columns of interest.

Torgo ed. 1, p. 44, footnote 6.     

Will start with just the output error fraction as an example.

```{r histErrFrac}
hist (msa_dt$rsr_COR_euc_out_err_frac)

hist (msa_dt$rsr_COR_euc_out_err_frac, prob=TRUE)
lines (density (msa_dt$rsr_COR_euc_out_err_frac, na.rm=TRUE))
rug (jitter (msa_dt$rsr_COR_euc_out_err_frac))
```

##  Show qqplot.

Torgo ed.1 pp. 45-6     

The function used in Torgo is `qq.plot`, but in latest version of `car` library, that function no longer exists.  It looks like you can use `qqplot` with 2 arguments or `qqnorm` with 1 argument (where that argument is assuming the normal distribution).

```{r qqErrFrac}
library (car)

qqnorm (msa_dt$rsr_COR_euc_out_err_frac, 
        main="Normal QQ plot for msa_dt$rsr_COR_euc_out_err_frac")
```

##  For comparison, here is what it would like with approximately normal data:

```{r qqRandomNormal}

qqnorm (rnorm (length (msa_dt$rsr_COR_euc_out_err_frac)), 
        main="Normal QQ plot for approx normal random data")
```

##  Show boxplot of a column.

Torgo ed.1, pp. 47-8     

```{r boxplot}
boxplot (msa_dt$rsr_COR_euc_out_err_frac, 
        ylab="msa_dt$rsr_COR_euc_out_err_frac")
rug (jitter (msa_dt$rsr_COR_euc_out_err_frac), side=2)
abline (h = mean (msa_dt$rsr_COR_euc_out_err_frac, na.rm=TRUE), lty=1)
abline (h = mean (msa_dt$rsr_COR_euc_out_err_frac, na.rm=TRUE) + 
            sd (msa_dt$rsr_COR_euc_out_err_frac, na.rm=TRUE), lty=2)
abline (h = median (msa_dt$rsr_COR_euc_out_err_frac, na.rm=TRUE), lty=3)
```

##  Interactively identify the data table row number of outliers 

This can't be done inside Rmarkdown so the code is shown below, but commented out.
Note that you can save the data table row numbers of the identified points by using the second set of lines below.

```{r identify}
#identify (msa_dt$rsr_COR_euc_out_err_frac)
    #  OR
#clickedLines <- identify (msa_dt$rsr_COR_euc_out_err_frac)
#msa_dt [clickedLines, ]
```

##  Show boxplots conditioned by a factor

Torgo ed.1, pp. 49-50

```{r conditionedBoxPlot}
library (lattice)

bwplot (rsp_combined_err_label ~ rsr_COR_euc_out_err_frac, data=msa_dt, 
        ylab="Error Type", xlab="rsr_COR_euc_out_err_frac")
        
```

##  Show conditioned box percentile plot (from Hmisc)

Torgo ed.1, pp. 50-1

```{r conditionedBoxPercentilePlot}
library (Hmisc)

bwplot (rsp_combined_err_label ~ rsr_COR_euc_out_err_frac, 
        data=msa_dt, 
        panel=panel.bpplot,
        probs=seq(.01,.49,by=.01),
        datadensity=TRUE, 
        ylab="Error Type", xlab="rsr_COR_euc_out_err_frac")
        
```

# Handling missing data

Section 2.5 of Torgo ed.1 discusses dealing with missing data.  At the moment, this is not an issue for the bdpg cases I'm looking at, so I will skip the code in this section except for the command to count complete rows.  I'll save that here just to remember that it exists.

##  Count the number of complete rows in the data table

Torgo ed.1, pp. 53

For this full data set, I don't think there are any rows that have no NAs, just because some of the columns only have data when certain flags are on.  For example, if not reading a problem from disk, then there won't be a file name for the problem to be read.

```{r completeRows}
nrow (msa_dt [ ! complete.cases (msa_dt), ])        
```
