#===============================================================================

                        #  test_gen_single_bdprob.R

#===============================================================================

library (bdpg)

context ("gen_single_bdprob")

#===============================================================================

    #----------------------------------------------------------------------
    #  Copies of parameters list generated by tzar from a particular run.
    #  These are here to use as the basis for building a parameters list
    #  for tests in building objects.
    #----------------------------------------------------------------------

if(FALSE)
{
parameters__full_including_marxan__original = list (
        marxan_pu_file_name = "pu.dat",
        too_many_possible_links_error_flag_file_name = "/Users/bill/tzar/outputdata/bdpgxupaper_4_variants_no_network_metrics/default_runset/39_marxan_simulated_annealing.inprogress/too_many_possible_links_error_flag_file.txt",
        desired_max_abundance_frac = 0.7,
        marxan_spf_rule = "POWER_OF_10",
        allow_imperfect_wrap = TRUE,
        spp_occ_FN_const_rate = 0.1,
        dep_set_PUs_eligible = FALSE,
        max_search_iterations = 500,
        use_igraph_metrics = TRUE,
        full_output_dir_with_slash = "/Users/bill/tzar/outputdata/bdpgxupaper_4_variants_no_network_metrics/default_runset/39_marxan_simulated_annealing.inprogress/",
        use_bipartite_metrics = TRUE,
        gen_multi_bdproblem = TRUE,
        solution_frac_of_landscape = 0.3,
        single_action_using_tzar_reps = FALSE,
        marxan_num_iterations = '1000000',
        p__prop_of_links_between_groups_lower_bound = 0.01,
        runset_abbrev = "bdpgSingleRunForTestAndDebug",
        max_allowed_possible_tot_num_links = 1500,
        read_Xu_problem_from_Xu_bench_file = FALSE,
        plot_rounded_abundances = TRUE,
        r__density_upper_bound = 5.0,
        marxan_puvspr_file_name = "puvspr.dat",
        p__prop_of_links_between_groups_upper_bound = 0.99,
        apply_error_to_spp_occupancy_data = TRUE,
        seed = 1,
        use_unif_rand_r__density = TRUE,
        wrap_lognormal_dist_around_Xu = TRUE,
        n__num_groups_upper_bound = 80,
        compute_network_metrics_APP = TRUE,
        spp_occ_FP_error_type = "CONSTANT",
        marxan_spec_file_name = "spec.dat",
        bdpg_run_init_rand_seed = 14329,
        marxan_input_parameters_file_name = "/Users/bill/tzar/modelcode/marxanLibrary_1360018653/input.dat",
        spp_occ_FP_const_rate = 0.0,
        integerize_string = "round",
        compute_network_metrics = FALSE,
        derive_alpha_from_n__num_groups_and_opt_frac_0.5 = TRUE,
        r__density_lower_bound = 0.01,
        desired_Xu_spp_frac_of_all_spp = 0.5,
        given_correct_solution_cost = 420,
        compute_network_metrics_wrapped_COR = TRUE,
        marxan_num_reps = 100,
        n__num_groups_lower_bound = 61,
        use_unif_rand_p__prop_of_links_between_groups = TRUE,
        marxan_use_default_input_parameters = FALSE,
        max_allowed_num_spp = 2000,
        run_id = 39,
        bipartite_metrics_to_use = "quick_test",
        marxan_runmode = 1,
        runset_description = "|, Small set of runs of a Xu hard scenario with error generation both on and off plus running simulated annealing and richness heuristic.",
        gen_4_basic_variants = TRUE,
        spp_occ_FN_error_type = "CONSTANT",
        marxan_heurtype = -1,
        set_rand_seed_at_creation_of_all_new_major_objects = FALSE,
        marxan_dir = "/Users/bill/tzar/modelcode/marxanLibrary_1360018653/",
        compute_network_metrics_COR = TRUE,
        use_unif_rand_n__num_groups = TRUE,
        Xu_bench_infile_name = "/Users/bill/D/Projects/ProblemDifficulty/data/Xu - problem difficulty datasets/frb30-15-msc with MSC 420/frb30-15-1.msc",
        add_one_to_lognormal_abundances = FALSE,
        match_error_counts = FALSE,
        compute_network_metrics_wrapped_APP = TRUE,
        runset_name = "default_runset"
        )

#----------------------------------------

parameters__full_including_marxan__grouped = list (

            #  general - run
        run_id = 39,
        runset_name = "default_runset",

        full_output_dir_with_slash = "/Users/bill/tzar/outputdata/bdpgxupaper_4_variants_no_network_metrics/default_runset/39_marxan_simulated_annealing.inprogress/",

        runset_abbrev = "bdpgSingleRunForTestAndDebug",
        runset_description = "|, Small set of runs of a Xu hard scenario with error generation both on and off plus running simulated annealing and richness heuristic.",

        seed = 1,
        bdpg_run_init_rand_seed = 14329,
        set_rand_seed_at_creation_of_all_new_major_objects = FALSE,

        integerize_string = "round",

        gen_4_basic_variants = TRUE,
        single_action_using_tzar_reps = FALSE,


            #  cor

                #  Xu from scratch
        max_allowed_num_spp = 2000,
        max_allowed_possible_tot_num_links = 1500,
        too_many_possible_links_error_flag_file_name = "/Users/bill/tzar/outputdata/bdpgxupaper_4_variants_no_network_metrics/default_runset/39_marxan_simulated_annealing.inprogress/too_many_possible_links_error_flag_file.txt",

        desired_Xu_spp_frac_of_all_spp = 0.5,
        derive_alpha_from_n__num_groups_and_opt_frac_0.5 = TRUE,

        use_unif_rand_n__num_groups = TRUE,
        n__num_groups_lower_bound = 61,
        n__num_groups_upper_bound = 80,

        use_unif_rand_p__prop_of_links_between_groups = TRUE,
        p__prop_of_links_between_groups_lower_bound = 0.01,
        p__prop_of_links_between_groups_upper_bound = 0.99,

        use_unif_rand_r__density = TRUE,
        r__density_lower_bound = 0.01,
        r__density_upper_bound = 5.0,

                #  Xu benchmark
        read_Xu_problem_from_Xu_bench_file = FALSE,
        given_correct_solution_cost = 420,
        Xu_bench_infile_name = "/Users/bill/D/Projects/ProblemDifficulty/data/Xu - problem difficulty datasets/frb30-15-msc with MSC 420/frb30-15-1.msc",


            #  network
        compute_network_metrics = FALSE,

        use_igraph_metrics = TRUE,
        use_bipartite_metrics = TRUE,
        compute_network_metrics_wrapped_COR = TRUE,
        compute_network_metrics_COR = TRUE,
        compute_network_metrics_wrapped_APP = TRUE,
        bipartite_metrics_to_use = "quick_test",
        compute_network_metrics_APP = TRUE,


            #  marxan
        marxan_num_iterations = '1000000',
        marxan_pu_file_name = "pu.dat",
        marxan_spf_rule = "POWER_OF_10",
        marxan_puvspr_file_name = "puvspr.dat",
        marxan_spec_file_name = "spec.dat",
        marxan_runmode = 1,
        marxan_input_parameters_file_name = "/Users/bill/tzar/modelcode/marxanLibrary_1360018653/input.dat",
        marxan_num_reps = 100,
        marxan_use_default_input_parameters = FALSE,
        marxan_heurtype = -1,
        marxan_dir = "/Users/bill/tzar/modelcode/marxanLibrary_1360018653/",


            #  wrap
        gen_multi_bdproblem = TRUE,

        solution_frac_of_landscape = 0.3,
        allow_imperfect_wrap = TRUE,
        dep_set_PUs_eligible = FALSE,
        max_search_iterations = 500,
        wrap_lognormal_dist_around_Xu = TRUE,
        add_one_to_lognormal_abundances = FALSE,
        plot_rounded_abundances = TRUE,
        desired_max_abundance_frac = 0.7,


            #  app
        apply_error_to_spp_occupancy_data = TRUE,

        spp_occ_FN_const_rate = 0.1,
        spp_occ_FP_error_type = "CONSTANT",
        spp_occ_FP_const_rate = 0.0,
        spp_occ_FN_error_type = "CONSTANT",
        match_error_counts = FALSE,

dummylistend=NULL
        )

}

#===============================================================================

                #-------------------------------
                #  Test gen_single_bdprob_WRAP
                #-------------------------------

test_gen_single_COR <- function (parameters
                                 #, bdpg_error_codes
                                 )
    {
    base_COR_bd_prob = gen_single_bdprob_COR (parameters,
                                              #bdpg_error_codes,
                                              integerize          = round,
                                              base_prob_name_stem = "base_prob",
                                              cor_dir_name_stem   = "cor"
                                              )

    cat ("\n\n-----  base_COR_bd_prob@UUID = '", base_COR_bd_prob@UUID,
         "', checksum = '", base_COR_bd_prob@checksum, "'  -----\n\n")

    cat ("\n\nfull_output_dir_with_slash = ",
         "\n    '", full_output_dir_with_slash, "'\n\n")

    return (base_COR_bd_prob)
    }

#-------------------------------------------------------------------------------

parameters = list (

            #  general - run
        run_id = 39,
        runset_name = "default_runset",

        full_output_dir_with_slash = "/Users/bill/tzar/outputdata/bdpgxupaper_4_variants_no_network_metrics/default_runset/39_marxan_simulated_annealing.inprogress/",

        runset_abbrev = "test_runset",
        runset_description = "test_runset long description",

        # seed = 1,
        bdpg_run_init_rand_seed = 14329,
        set_rand_seed_at_creation_of_all_new_major_objects = FALSE,

        integerize_string = "round",

        # gen_4_basic_variants = TRUE,
        # single_action_using_tzar_reps = FALSE,

            #  cor - Xu from scratch

        read_Xu_problem_from_Xu_bench_file = FALSE,

        max_allowed_num_spp = 2000,
        max_allowed_possible_tot_num_links = 1500,
        too_many_possible_links_error_flag_file_name = "/Users/bill/tzar/outputdata/bdpgxupaper_4_variants_no_network_metrics/default_runset/39_marxan_simulated_annealing.inprogress/too_many_possible_links_error_flag_file.txt",

        desired_Xu_spp_frac_of_all_spp = 0.5,
        derive_alpha_from_n__num_groups_and_opt_frac_0.5 = TRUE,

        use_unif_rand_n__num_groups = TRUE,
        n__num_groups_lower_bound = 61,
        n__num_groups_upper_bound = 80,

        use_unif_rand_p__prop_of_links_between_groups = TRUE,
        p__prop_of_links_between_groups_lower_bound = 0.01,
        p__prop_of_links_between_groups_upper_bound = 0.99,

        use_unif_rand_r__density = TRUE,
        r__density_lower_bound = 0.01,
        r__density_upper_bound = 5.0,


            #  network
        compute_network_metrics = FALSE,

            #  wrap
        # gen_multi_bdproblem = TRUE,
        #
        # solution_frac_of_landscape = 0.3,
        # allow_imperfect_wrap = TRUE,
        # dep_set_PUs_eligible = FALSE,
        # max_search_iterations = 500,
        # wrap_lognormal_dist_around_Xu = TRUE,
        # add_one_to_lognormal_abundances = FALSE,
        # plot_rounded_abundances = TRUE,
        # desired_max_abundance_frac = 0.7,


dummylistend=NULL
        )

#  TEMPORARY
parameters$at_least_1_for_target_num_links_between_2_groups_per_round = FALSE

#-------------------------------------------------------------------------------

    #  Create test output directory.
full_output_dir = tempdir()
last_char = substr (full_output_dir, nchar(full_output_dir), nchar(full_output_dir))
full_output_dir_with_slash =
    if (last_char == "/") full_output_dir else paste0 (full_output_dir, "/")

parameters$full_output_dir_with_slash                   = full_output_dir_with_slash    #"/Users/bill/tzar/outputdata/bdpgxupaper_4_variants_no_network_metrics/default_runset/39_marxan_simulated_annealing.inprogress/"
parameters$too_many_possible_links_error_flag_file_name =
    paste0 (full_output_dir_with_slash, "too_many_possible_links_error_flag_file.txt")  #"/Users/bill/tzar/outputdata/bdpgxupaper_4_variants_no_network_metrics/default_runset/39_marxan_simulated_annealing.inprogress/too_many_possible_links_error_flag_file.txt"

    #  Initialize for a bdpg run.
params_and_error_codes = init_for_bdpg (parameters)

#bdpg_error_codes = params_and_error_codes$bdpg_error_codes
parameters       = params_and_error_codes$parameters

#-------------------------------------------------------------------------------

    #  Generate a correct problem from scratch.
bdprob_COR_1 = test_gen_single_COR (parameters
                                    #,
                                    #bdpg_error_codes
                                    )

test_that("gen_single_bdprob_COR: COR problem generation succeed", {
    expect_true (! is.null (bdprob_COR_1))
})

    #  Both the identical() function and the comparison of problem checksums
    #  should show when two problems are the same, even if their UUIDs are
    #  different.
bdprob_COR_2 = bdprob_COR_1

test_that("gen_single_bdprob_COR: problem is identical to itself", {
    expect_true (identical (bdprob_COR_1, bdprob_COR_1))
    expect_true (identical (bdprob_COR_2, bdprob_COR_1))
})

        #  Change the copy's UUID and put it back after the test.
hold_UUID = bdprob_COR_2@UUID
bdprob_COR_2@UUID = "123"
checksum_of_prob2 = compute_obj_checksum (bdprob_COR_2)

test_that("gen_single_bdprob_COR: problem copy with different UUID has same checksum", {
    expect_true (checksum_of_prob2 == bdprob_COR_1@checksum)
})
bdprob_COR_2@UUID = hold_UUID  #  Put back to old value.

    #  Problems should not be identical if you change a subelement of them,
    #  e.g., changing a single element of the occurrence matrix.
hold_bpm = bdprob_COR_2@bpm
bdprob_COR_2@bpm[2,3] = hold_bpm[2,3] + 1
checksum_of_prob2_with_different_bpm = compute_obj_checksum (bdprob_COR_2)

test_that("gen_single_bdprob_COR: problem copy with modified bpm is not identical to original", {
    expect_true (!identical (bdprob_COR_2, bdprob_COR_1))
    expect_true (checksum_of_prob2_with_different_bpm != bdprob_COR_1@checksum)
})
bdprob_COR_2@bpm[2,3] = bdprob_COR_2@bpm[2,3] - 1  #  Put back to old value.

checksum_of_prob2_with_original_bpm = compute_obj_checksum (bdprob_COR_2)
test_that("gen_single_bdprob_COR: problem copy with bpm modified back to original values by arithmetic is identical to original", {
    expect_true (identical (bdprob_COR_2, bdprob_COR_1))
    expect_true (checksum_of_prob2_with_original_bpm == bdprob_COR_1@checksum)
})

bdprob_COR_2@bpm = hold_bpm
checksum_of_prob2_with_original_bpm = compute_obj_checksum (bdprob_COR_2)
test_that("gen_single_bdprob_COR: problem copy with bpm modified back by matrix replacement is identical to original", {
    expect_true (identical (bdprob_COR_2, bdprob_COR_1))
    expect_true (checksum_of_prob2_with_original_bpm == bdprob_COR_1@checksum)
})

    #  A completely different problem should not be identical to the first
    #  problem or have the same checksum.
bdprob_COR_3 = test_gen_single_COR (parameters
                                    #,
                                    #bdpg_error_codes
                                    )

test_that("gen_single_bdprob_COR: different problem is not identical to original", {
    expect_true (! identical (bdprob_COR_3, bdprob_COR_1))
    expect_true (bdprob_COR_3@checksum != bdprob_COR_1@checksum)
})

#  NEED TEST FOR GENERATION OF SAME OBJECT IF GIVEN THE SAME INITIAL RANDOM
#  NUMBER SEED.  NOT SURE IF THAT'S PASSED IN TO THE OBJECT GENERATOR OR SET
#  BEFORE YOU CALL THE GENERATOR.

temp_parameters = parameters
temp_parameters[["cor_base_rsprob_rand_seed"]] = 11

bdprob_COR_4 = test_gen_single_COR (temp_parameters
                                    #,
                                    #bdpg_error_codes
                                    )

bdprob_COR_5 = test_gen_single_COR (temp_parameters
                                    #,
                                    #bdpg_error_codes
                                    )

test_that("gen_single_bdprob_COR: 2 problems generated from same seed are the same up to UUID", {
    expect_true (! identical (bdprob_COR_4, bdprob_COR_5))  # different UUIDs
    expect_equal (bdprob_COR_4@rand_seed, bdprob_COR_5@rand_seed)
    expect_equal (as.character (bdprob_COR_4@checksum),
                  as.character (bdprob_COR_5@checksum))
    expect_equal (bdprob_COR_4@checksum, bdprob_COR_5@checksum)
})

    #  Test that you can generate the same table of species occurrences
    #  using the direct parameters rather than the 4 Xu metaparameters.

temp_parameters = parameters

temp_parameters$dont_derive_prob_params_from_4_Xu_metaparams = TRUE
temp_parameters$tot_num_nodes = 142
temp_parameters$num_nodes_per_group = 2
temp_parameters$n__num_groups = 71
temp_parameters$num_independent_nodes_per_group = 1
temp_parameters$max_possible_tot_num_links = 71
temp_parameters$target_num_links_between_2_groups_per_round = 0  # <<<---
temp_parameters$num_rounds_of_linking_between_groups = 1438


bdprob_COR_6 = test_gen_single_COR (temp_parameters
                                    #,
                                    #bdpg_error_codes
                                    )

test_that("gen_single_bdprob_COR: 2 problems generated from metaparams and derived params are the same up to UUID", {
    expect_true (! identical (bdprob_COR_1, bdprob_COR_6))  # different UUIDs
    expect_true (all.equal (bdprob_COR_1@cor_PU_spp_pair_indices,
                            bdprob_COR_6@cor_PU_spp_pair_indices))
})


#  NEED TEST FOR WHAT HAPPENS IF NO MAX NUM SPP ALLOWED IS GIVEN IN PARAMETERS.

temp_parameters = parameters
temp_parameters$max_allowed_num_spp = NULL

bdprob_COR_7 = test_gen_single_COR (temp_parameters
                                    #,
                                    #bdpg_error_codes
                                    )


#  NEED TEST FOR ALLOWING RETRIES IF MAX NUM SPP ALLOWED IS EXCEEDED.
#  CAN FORCE THIS BY GIVING AN ABSURDLY LOW NUMBER OF SPP ALLOWED, E.G, 1.

#===============================================================================

